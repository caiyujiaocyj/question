import numpy as np

def load_sur_normals_from_npz(npz_path, key="sur_normals"):
    """
    兼容两种常见情况：
    1) np.savez 保存了一个 dict（会变成 dtype=object 的 0-d array），需要 .item()
    2) sur_normals 直接就是 ndarray
    """
    data = np.load(npz_path, allow_pickle=True)
    if key not in data:
        raise KeyError(f"Key '{key}' not found in npz. Available keys: {list(data.keys())}")

    obj = data[key]
    if isinstance(obj, np.ndarray) and obj.dtype == object:
        # 常见：0-d object array，里面装了 dict
        obj = obj.item()
    return obj

def compute_component_variance(normals):
    """
    normals: (N,3) array, 每行 [nx, ny, nz]
    返回：var_x + var_y + var_z
    """
    normals = np.asarray(normals, dtype=np.float64)
    if normals.ndim != 2 or normals.shape[1] != 3:
        raise ValueError(f"normals must have shape (N,3), got {normals.shape}")

    # 分量均值
    mean = normals.mean(axis=0)              # [mean_nx, mean_ny, mean_nz]
    # 分量方差（按 1/N）
    var_xyz = ((normals - mean) ** 2).mean(axis=0)  # [var_x, var_y, var_z]
    return float(var_xyz.sum()), var_xyz

def normals_variance_from_npz(npz_path, dict_key="sur_normals", normals_key=None):
    """
    npz_path: npz文件路径
    dict_key: npz里的key名（默认 sur_normals）
    normals_key:
        - 如果 sur_normals 是 dict: 指定取哪个字段作为 normals (N,3)
        - 如果不指定，会自动猜：优先找 'normals','sur_normals','n','normal'
          否则取 dict 里第一个形状为 (N,3) 的数组
    """
    sur_normals = load_sur_normals_from_npz(npz_path, key=dict_key)

    # 情况A：sur_normals 本身就是 ndarray
    if isinstance(sur_normals, np.ndarray) and sur_normals.dtype != object:
        var_sum, var_xyz = compute_component_variance(sur_normals)
        return {"var_sum": var_sum, "var_xyz": var_xyz, "picked_key": None}

    # 情况B：sur_normals 是 dict
    if not isinstance(sur_normals, dict):
        raise TypeError(f"Expected dict or ndarray for '{dict_key}', got {type(sur_normals)}")

    # 如果用户明确给了 normals_key
    if normals_key is not None:
        if normals_key not in sur_normals:
            raise KeyError(f"'{normals_key}' not in sur_normals keys: {list(sur_normals.keys())}")
        normals = sur_normals[normals_key]
        var_sum, var_xyz = compute_component_variance(normals)
        return {"var_sum": var_sum, "var_xyz": var_xyz, "picked_key": normals_key}

    # 自动猜 key
    preferred = ["normals", "sur_normals", "n", "normal", "sur_normal", "surface_normals"]
    for k in preferred:
        if k in sur_normals:
            try:
                var_sum, var_xyz = compute_component_variance(sur_normals[k])
                return {"var_sum": var_sum, "var_xyz": var_xyz, "picked_key": k}
            except Exception:
                pass

    # 兜底：找第一个形状像 (N,3) 的数组
    for k, v in sur_normals.items():
        try:
            var_sum, var_xyz = compute_component_variance(v)
            return {"var_sum": var_sum, "var_xyz": var_xyz, "picked_key": k}
        except Exception:
            continue

    raise ValueError(
        "Could not find any (N,3) normals array inside sur_normals dict. "
        f"Keys: {list(sur_normals.keys())}"
    )

def is_plane_like_by_normal_variance(var_sum, threshold=0.01):
    """
    简单判定：法向分量方差和小于阈值 => 平面倾向
    """
    return var_sum < threshold

# ------------------ 使用示例 ------------------
if __name__ == "__main__":
    npz_path = "/path/to/your_file.npz"

    out = normals_variance_from_npz(npz_path, dict_key="sur_normals", normals_key=None)
    var_sum = out["var_sum"]
    var_xyz = out["var_xyz"]

    print("picked_key:", out["picked_key"])
    print("var_x,var_y,var_z:", var_xyz)
    print("var_sum:", var_sum)

    if is_plane_like_by_normal_variance(var_sum, threshold=0.01):
        print("=> This cluster looks PLANE-like (normals too consistent).")
    else:
        print("=> This cluster looks NOT plane-like (normals vary).")
