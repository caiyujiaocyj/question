import os
import glob
import pickle
import numpy as np
from typing import Any, Dict, List, Tuple, Optional


def load_pts(file_path_txt: str) -> np.ndarray:
    """Load points from a block txt file. Only use x,y,z (first 3 columns)."""
    data = np.loadtxt(file_path_txt)
    xyz = data[:, :3].astype(np.float32)
    return xyz


def save_pc_xyz(xyz: np.ndarray, out_path: str) -> None:
    """Save xyz to txt."""
    os.makedirs(os.path.dirname(out_path), exist_ok=True)
    np.savetxt(out_path, xyz, fmt="%.6f")


def append_pc_xyz(xyz: np.ndarray, out_path: str) -> None:
    os.makedirs(os.path.dirname(out_path), exist_ok=True)
    with open(out_path, "a") as f:
        np.savetxt(f, xyz, fmt="%.6f")


def load_pkl(fname: str) -> Any:
    with open(fname, "rb") as f:
        return pickle.load(f)


def filter_cyls(cyls: List[Dict[str, Any]], max_radius: float = 0.02) -> List[Dict[str, Any]]:
    return [c for c in cyls if c["extend_inf"]["radius"] < max_radius]


def get_bbox(pts: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:
    mn = np.min(pts, axis=0)
    mx = np.max(pts, axis=0)
    return mn, mx


def _clip_segment_to_aabb(p0: np.ndarray, p1: np.ndarray, mn: np.ndarray, mx: np.ndarray, radius) -> Optional[Tuple[np.ndarray, np.ndarray, np.ndarray]]:
    """
    p0, p1, radius: start point, end point and radius of a cyn.
    mn = [xmin, ymin, zmin], mx = [xmax, ymax, zmax], the bbox information.
    """
    t0, t1 = 0.0, 1.0
    d = p1 - p0
    for i in range(3):
        if abs(d[i]) < 1e-12:
            if p0[i] < mn[i] or p0[i] > mx[i]:
                return None
        else:
            inv = 1.0 / d[i]
            tE = (mn[i] - p0[i]) * inv
            tL = (mx[i] - p0[i]) * inv
            if tE > tL:
                tE, tL = tL, tE
            t0 = max(t0, tE)
            t1 = min(t1, tL)
            if t0 > t1:
                return None
    return p0 + t0 * d, p0 + t1 * d, radius


def clip_cyls_to_bbox(cyls: List[Dict[str, Any]], mn: np.ndarray, mx: np.ndarray) -> List[Dict[str, Any]]:
    """
     clip cyls within the bbox range
     input:
       cyls : dict information for a cyn, include start point, end point and radius.
       mn = [xmin, ymin, zmin], mx = [xmax, ymax, zmax], the bbox information.
     output:
       cyls : dict information for clipped cyn, include start point, end point and radius.
       """
    out = []
    for c in cyls:
        res = _clip_segment_to_aabb(c["extend_inf"]["start"], c["extend_inf"]["end"], mn, mx, c["extend_inf"]["radius"])
        if res is not None:
            s, e, r = res
            cc = dict(c)
            cc["start"] = s
            cc["end"] = e
            cc["radius"] = r
            out.append(cc)
    return out


def point_to_line_distance_v2(pts: np.ndarray, a: np.ndarray, b: np.ndarray) -> np.ndarray:
    """
    Distance from point(s) to infinite line through segment AB.
    pts: (N,3), a/b: (3,)
    returns: (N,)
    """
    ab = b - a
    ab2 = np.dot(ab, ab)
    if ab2 < 1e-12:
        # degenerate
        return np.linalg.norm(pts - a[None, :], axis=1)

    ap = pts - a[None, :]
    # projection length onto AB (not clamped)
    t = (ap @ ab) / ab2  # (N,)
    proj = a[None, :] + t[:, None] * ab[None, :]
    return np.linalg.norm(pts - proj, axis=1)


def get_pc_mask_inside_cylinder(pts, start, end, radius, len_ext=0.02):
    """
    :param pts: (N, 3)
    :param start: (3,)
    :param end: (3,)
    :param radius:
    :param len_ext: extending length (unit is m), length of the cylinder_plane-1191 used for indices computation is len_cyl + len_ext.
    :return:
        mask_inside: (N,)
    """
    direction = end - start  # Cylinder direction.
    len_cyl = np.linalg.norm(direction)  # Cylinder length.
    direction = direction / len_cyl  # Normalized cylinder_plane-1191 direction.

    if len_cyl < 1e-6:
        mask_inside = np.zeros_like(pts[:, 0], dtype=bool)
        return mask_inside

    # Compute the mask: distance<pc, axis> < radius.
    mask_inside_along_normal = point_to_line_distance_v2(pts, start, end) < radius

    # Compute the mask: pc is between start_ext and end_ext.
    start_ext = start - direction * len_ext  # Extended start.
    end_ext = end + direction * len_ext  # Extended end.
    ES = start_ext - end_ext  # (3,)
    SE = -ES  # (3,)
    SP = pts - start_ext  # (N, 3)
    EP = pts - end_ext  # (N, 3)
    mask_inside_along_direction = (np.sum(SP * SE, axis=1) > 0) & (np.sum(EP * ES, axis=1) > 0)

    mask_inside = mask_inside_along_normal & mask_inside_along_direction
    return mask_inside


def process_blocks(fname_gt: str, fdir_pc: str, out_dir: str, max_radius: float = 0.02, radius_ext: float = 0.02,
                   len_ext: float = 0.02, glob_pattern: str = "*.txt", merged_name: str = "merged_all_pc.txt"
) -> None:
    """
    For each block txt: keep points near clipped cylinders.
    input:
        max_radius: maximum radius of filter target cyn
        radius_ext: extend radius range
        len_ext: extend cyn's start and end range
    output:
        save extract pc's xyz information around cylinders by block.
        save merge all block saved pc's xyz information.
    """
    all_cyls = load_pkl(fname_gt)
    useful_cyls = filter_cyls(all_cyls, max_radius=max_radius) #只保留半径小于0.02的圆柱

    for i, cyl in enumerate(all_cyls):
        radius = cyl["extend_inf"]["radius"]
        print(f"radius = {radius:.6f}")

    block_files = sorted(glob.glob(os.path.join(fdir_pc, glob_pattern)))
    if len(block_files) == 0:
        raise FileNotFoundError(f"No block txt files found under: {fdir_pc} with pattern {glob_pattern}")

    print(f"total cylinders parsed: {len(all_cyls)}")
    print(f"cylinders after radius<{max_radius}: {len(useful_cyls)}")
    print(f"total blocks: {len(block_files)}")
    print(f"len_ext: {len_ext}")
    os.makedirs(out_dir, exist_ok=True)

    merged_path = os.path.join(out_dir, merged_name)
    with open(merged_path, "w") as f:
        pass
    print(f"merged file: {merged_path}")

    for bi, block_txt in enumerate(block_files):
        pts = load_pts(block_txt)
        mn, mx = get_bbox(pts) #点云所在的bbox
        clipped = clip_cyls_to_bbox(useful_cyls, mn, mx) #只保留bbox内部的圆柱

        reserved_idx_list = []
        for c in clipped:
            start = c["start"]
            end = c["end"]
            radius = c["radius"] + radius_ext #适当放大圆柱的半径

            mask_inside = get_pc_mask_inside_cylinder(pts, start, end, radius, len_ext=len_ext)
            idx = np.where(mask_inside)[0].astype(np.int64)

            if idx.size > 0:
                reserved_idx_list.append(idx)

        if len(reserved_idx_list) == 0:
            final_idx = np.array([], dtype=np.int64)
        else:
            final_idx = np.unique(np.concatenate(reserved_idx_list, axis=0)) #对索引去重

        out_name = os.path.splitext(os.path.basename(block_txt))[0] + "_pc.txt"
        out_path = os.path.join(out_dir, out_name)
        if final_idx.size > 0:
            save_pc_xyz(pts[final_idx], out_path) # 保存抽取的点云坐标
            append_pc_xyz(pts[final_idx], merged_path) #合并保存所有block中抽取的点云坐标

        if (bi + 1) % 10 == 0 or bi == 0 or bi == len(block_files) - 1:
            print(f"{bi+1}/{len(block_files)} saved: {out_path} (kept {final_idx.size}/{pts.shape[0]})")


if __name__ == "__main__":
    fname_gt = "D:\\cyj\P&D_15L_ABC_seg1.0.pkl"
    fdir_pc = "D:\cyj\\txt1216"
    out_pc = "D:\\cyj\\txt1216"
    len_ext = 0.02
    out_dir = os.path.join(out_pc, f"pc_near_cylinders_len_ext={len_ext:.2f}")
    process_blocks(
        fname_gt=fname_gt,
        fdir_pc=fdir_pc,
        out_dir=out_dir,
        max_radius=0.02,
        radius_ext = 0.02,
        len_ext=len_ext,
        glob_pattern="*.txt",
        merged_name = "merged_all_pc.txt"
    )
