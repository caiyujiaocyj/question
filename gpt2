#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
在原 visualize_20251021_cyj.py 基础上，仅增加柱体ID标签显示功能。
保留所有原有功能和绘制方式（add_cylinder 绘制线段柱体不变）。
"""

import copy
import numpy as np
import os
import pickle
import glob
from tqdm import tqdm
import argparse
import open3d as o3d
from open3d import geometry

LST_COLOR = [[0.6, 0.6, 0.6]] + [np.random.rand(3).tolist() for _ in range(100000)] + [[0, 0, 0]]
THR_NUM_PTS_VALID = 10


# ======================================================
# 新增：标签函数（支持 add_3d_label 或小球兜底）
# ======================================================
def add_label_with_fallback(vis, position, text, color):
    """
    优先使用 vis.add_3d_label 添加文字标签；
    如果不可用，则使用彩色小球作为标签标记。
    """
    pos = np.asarray(position, float).reshape(3,)
    try:
        vis.add_3d_label(pos, text)
    except Exception:
        sphere = o3d.geometry.TriangleMesh.create_sphere(radius=0.03)
        sphere.translate(pos)
        sphere.paint_uniform_color(color)
        vis.add_geometry(sphere)
        print(f"[fallback] label -> sphere at {pos.tolist()} text={text}")


# ======================================================
# 原有函数（保持不动）
# ======================================================
def parse_args():
    parser = argparse.ArgumentParser(description='')
    parser.add_argument('--dir_root', default='exp/NRDK/baseline_s2/result_gt_seg', type=str, help='')
    parser.add_argument('--rel_dir_fitted', type=str, default='cylinder_fitting_mcwei_20250929', help='')
    args = parser.parse_args()
    args.dir_fitted = os.path.join(args.dir_root, args.rel_dir_fitted)
    args.dir_save_for_vis = os.path.join(args.dir_root, args.rel_dir_fitted, 'save_for_vis')
    return args


def point_to_line_distance_v2(pts, A, B):
    A = np.array(A)
    B = np.array(B)
    AB = B - A
    if np.linalg.norm(AB) < 1e-10:
        return np.linalg.norm(pts - A, axis=1)
    AP = pts - A
    cross_product = np.cross(AP, AB)
    cross_norm = np.linalg.norm(cross_product, axis=1)
    dis = cross_norm / np.linalg.norm(AB)
    return dis


def get_pc_mask_inside_cylinder(pts, start, end, radius, len_ext=0.02):
    direction = end - start
    len_cyl = np.linalg.norm(direction)
    if len_cyl < 1e-6:
        return np.zeros_like(pts[:, 0], dtype=bool)
    direction = direction / len_cyl
    mask_inside_along_normal = point_to_line_distance_v2(pts, start, end) < radius
    start_ext = start - direction * len_ext
    end_ext = end + direction * len_ext
    ES = start_ext - end_ext
    SE = -ES
    SP = pts - start_ext
    EP = pts - end_ext
    mask_inside_along_direction = (np.sum(SP * SE, axis=1) > 0) & (np.sum(EP * ES, axis=1) > 0)
    mask_inside = mask_inside_along_normal & mask_inside_along_direction
    return mask_inside


# ======================================================
# 可视化逻辑：增加标签显示
# ======================================================
def vis_custom(data, vis):
    pcd, lst_param = data
    pts = pcd['pts']
    id = pcd['id']

    for id_ins in np.unique(id[:, ]):
        i_color = int(id_ins)
        color = LST_COLOR[i_color + 1]
        p = o3d.geometry.PointCloud()
        p.points = o3d.utility.Vector3dVector(pts[id == id_ins])
        p.paint_uniform_color(color)
        vis.add_geometry(p)

    for param in lst_param:
        if param is None:
            continue
        if ('radius' in param):
            color = LST_COLOR[param.get('id', 1) + 1]
            add_cylinder(vis, param, color=color)

            # ===== 新增部分：为每个柱体添加标签 =====
            if 'id' in param:
                start = np.asarray(param['start'], float)
                end = np.asarray(param['end'], float)
                radius = float(param['radius'])
                center = (start + end) / 2.0
                axis = end - start
                n = np.linalg.norm(axis)
                axis_dir = axis / n if n > 1e-6 else np.array([0, 0, 1.0])
                pos = center + axis_dir * (radius + 0.08)
                add_label_with_fallback(vis, pos, f"ID:{param['id']}", color)
    return


# ======================================================
# 以下部分完全保持原逻辑
# ======================================================
def create_cylinder_line(start, end, radius=0.001, color=[1, 0, 0]):
    direction = np.subtract(end, start)
    length = np.linalg.norm(direction)
    if length < 1e-6:
        return None

    direction_unit = direction / length
    cylinder = o3d.geometry.TriangleMesh.create_cylinder(radius=radius, height=length, resolution=4)

    z_axis = np.array([0, 0, 1])
    rotation_axis = np.cross(z_axis, direction_unit)
    rotation_angle = np.arccos(np.dot(z_axis, direction_unit))

    if np.linalg.norm(rotation_axis) > 1e-6:
        rotation_axis = rotation_axis / np.linalg.norm(rotation_axis)
        rotation_matrix = o3d.geometry.get_rotation_matrix_from_axis_angle(rotation_axis * rotation_angle)
        cylinder.rotate(rotation_matrix, center=(0, 0, 0))

    cylinder.translate(np.mean([start, end], axis=0))
    cylinder.paint_uniform_color(color)
    return cylinder


def add_cylinder(vis, cyl, color, transparent=False, line_radius=0.002):
    if isinstance(cyl, dict):
        start = np.array(cyl['start'])
        end = np.array(cyl['end'])
        radius = cyl['radius']
    elif isinstance(cyl, list):
        start = np.array(cyl[0])
        end = np.array(cyl[1])
        radius = cyl[2]
    else:
        raise TypeError(type(cyl))

    v = end - start
    height = np.linalg.norm(v)
    if height < 1e-6:
        print(f"Cylinder has zero height, skipped.")
        return
    v_unit = v / height

    center_line = create_cylinder_line(start, end, radius=line_radius, color=color)
    vis.add_geometry(center_line)

    if abs(v_unit[0]) > 0.5:
        u = np.cross(v_unit, [0, 1, 0])
    else:
        u = np.cross(v_unit, [1, 0, 0])
    u = u / np.linalg.norm(u)
    w = np.cross(v_unit, u)
    w = w / np.linalg.norm(w)

    num_segments = 16
    angles = np.linspace(0, 2 * np.pi, num_segments, endpoint=False)
    top_points = [start + radius * (np.cos(a) * u + np.sin(a) * w) for a in angles]
    bottom_points = [end + radius * (np.cos(a) * u + np.sin(a) * w) for a in angles]

    for i in range(num_segments):
        top_edge = create_cylinder_line(top_points[i], top_points[(i + 1) % num_segments], radius=line_radius, color=color)
        bottom_edge = create_cylinder_line(bottom_points[i], bottom_points[(i + 1) % num_segments], radius=line_radius, color=color)
        vis.add_geometry(top_edge)
        vis.add_geometry(bottom_edge)

    for i in range(0, num_segments, 2):
        edge = create_cylinder_line(top_points[i], bottom_points[i], radius=line_radius, color=color)
        vis.add_geometry(edge)
    return


# ======================================================
# 交互逻辑（保持不动）
# ======================================================
def vis_compare_2_pc(func_vis, lst_data1, lst_data2, path_save_base, custom_keys_for_save=('A', 'S', 'D'),
                     full_screen=False, show_ids=False):
    def toggle_cloud(vis):
        current_view = vis.get_view_control().convert_to_pinhole_camera_parameters()
        global show_1st
        show_1st = not show_1st
        vis.clear_geometries()
        if show_1st:
            func_vis(lst_data1, vis)
        else:
            func_vis(lst_data2, vis)
        vis.get_view_control().convert_from_pinhole_camera_parameters(current_view)
        vis.update_renderer()
        return True

    def custom_save_screenshot(k):
        def callback(vis):
            global show_1st
            suffix = '_correct' if show_1st else '_origin'
            path_save = path_save_base.replace('.png', '') + f'{suffix}.png'
            path_save = os.path.join(os.path.dirname(path_save), f'{k}_{os.path.basename(path_save)}')
            vis.capture_screen_image(path_save)

            current_view = vis.get_view_control().convert_to_pinhole_camera_parameters()
            vis.clear_geometries()
            show_1st = not show_1st
            if show_1st:
                func_vis(lst_data1, vis)
            else:
                func_vis(lst_data2, vis)
            vis.get_view_control().convert_from_pinhole_camera_parameters(current_view)
            vis.poll_events()
            vis.update_renderer()

            suffix = '_correct' if suffix == '_origin' else '_origin'
            path_save = path_save_base.replace('.png', '') + f'{suffix}.png'
            path_save = os.path.join(os.path.dirname(path_save), f'{k}_{os.path.basename(path_save)}')
            vis.capture_screen_image(path_save)
            vis.destroy_window()
            return True
        return callback

    vis = o3d.visualization.VisualizerWithKeyCallback()
    if full_screen:
        vis.create_window(window_name=os.path.basename(path_save_base).replace('.png', ''))
    else:
        vis.create_window(width=800, height=800, window_name=os.path.basename(path_save_base).replace('.png', ''))

    os.makedirs(os.path.dirname(path_save_base), exist_ok=True)
    global show_1st
    show_1st = True
    func_vis(lst_data1, vis)
    if lst_data2 is not None:
        vis.register_key_callback(ord("T"), toggle_cloud)
    for key in custom_keys_for_save:
        vis.register_key_callback(ord(key), custom_save_screenshot(key))
    print("按 T 键切换视图, Esc 退出")
    vis.run()


# ======================================================
# 数据加载逻辑（保持不动）
# ======================================================
def vis_single_block(path_pc, args):
    dir_save_for_vis = args.dir_save_for_vis
    name = os.path.basename(path_pc).replace('pkl', '')
    res_fitting = pickle.load(open(os.path.join(dir_save_for_vis, f'{os.path.basename(path_pc)}.pkl'), 'rb'))
    res_eval = pickle.load(open(os.path.join(dir_save_for_vis, f'eval_{os.path.basename(path_pc)}.pkl'), 'rb'))
    gt = res_eval['gt']
    lst_idx_gt_unmatched = res_eval['ug']
    if not lst_idx_gt_unmatched:
        return
    pc = np.loadtxt(path_pc)
    ind_pc = res_fitting['ind_pts']
    pc = pc[ind_pc]
    pc = pc[pc[:, 10] == 1]
    mask_pc_fn = np.zeros_like(pc[:, 0], dtype=bool)
    lst_idx_gt_unmatched_valid = []
    for idx_gt in lst_idx_gt_unmatched:
        cyl = res_eval['gt'][idx_gt]
        mask_i = get_pc_mask_inside_cylinder(pc[:, :3], cyl['start'], cyl['end'], cyl['radius'] + 0.02, len_ext=0.02)
        if sum(mask_i) > THR_NUM_PTS_VALID:
            lst_idx_gt_unmatched_valid.append(idx_gt)
        mask_pc_fn |= mask_i
    if not lst_idx_gt_unmatched_valid:
        return
    lst_gt_fn = [gt[idx_gt] for idx_gt in lst_idx_gt_unmatched_valid]
    pc_fitted = copy.deepcopy(pc)
    pc_fitted[:, 11] = -1
    pc_fitted[:, 12] = -1
    lst_pred = []
    for i in range(len(res_fitting['results'])):
        ind_clustered = res_fitting['results'][i]['ind_clustered']
        ind_inlier = res_fitting['results'][i]['ind_inlier']
        d = res_fitting['results'][i]['d']
        start = res_fitting['results'][i]['start']
        end = res_fitting['results'][i]['end']
        radius = res_fitting['results'][i]['radius']
        cyl = dict(start=start, end=end, radius=radius)
        length = res_fitting['results'][i]['length']
        if len(np.intersect1d(mask_pc_fn.nonzero()[0], ind_inlier)):
            cyl['id'] = i + 1
            lst_pred.append(cyl)

    path_vis = os.path.join(args.dir_root, 'vis', f'{name}.png')
    vis_compare_2_pc(vis_custom, [pc_fitted, lst_pred], [pc_fitted, lst_gt_fn], path_vis, show_ids=True)
    return


def main(args):
    lst_path_pc = glob.glob(os.path.join(args.dir_root, "*.pts"))
    for i, path_pc in enumerate(lst_path_pc):
        print(f'visualize: {i}')
        vis_single_block(path_pc, args)
    return


if __name__ == '__main__':
    main(parse_args())