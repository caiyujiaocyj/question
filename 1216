'''
任务：抽取某些圆柱附近的点云。
input: 
  圆柱信息所在文件fname_gt: "/media/samsung/samsung/DigitalTwin2025/dataset/HQdata/mcwei_test/GTGen/15L_CSF/3D Modeling_A-D/P&D_15L_ABC_seg1.0.pkl"
  点云所在目录fdir_pc: "/media/samsung/samsung/DigitalTwin2025/dataset/HQdata/15L_CSF/Area_real_1124_r0.005_x3y3z3_txt", 里面每个txt文件对应于一个block，txt文件里每行对应于一个点，7个数分别是x,y,z,I,R,G,B，只有前3个数是有用的.圆柱信息存在字典extend_inf中，extend_inf也是一个字典，包含“start”“end”“radius”。
output:
  每个block独立处理，保留的点云保存在单独的文件里.
''''

#算法流程:

all_cyns = load_cyns_from_pkl(fname_gt)
useful_cyns = filter_cyns(all_cyns)  #只保留半径小于0.02的圆柱

lst_block_txt_files = [] #a list, fdir_pc里的每个txt文件

for block_txt_file in lst_block_txt_files:
  pc_all = load_pts(block_txt_file)
  bbox = get_bbox(pc_all)  #点云所在的bbox
  clipped_cyns = clip_cyn(useful_cyns, bbox)   #只保留bbox内部的圆柱

  pc_reserved = []
  for cyn in clipped_cyns:
      ind_pc = get_pc_inside_cylinder(pc_all, cyn)  #调用get_pc_mask_inside_cylinder_org，注意适当放大圆柱的半径. 返回值是pc_all的一个子集，index形式.
      pc_reserved.extend(ind_pc)

  pc_final = remove_duplicate(pc_reserved) #直接对索引去重

  save_pc(pc_all[pc_final], fname_output_each_block)


'''
utility functions:
1. load_pts:
   data = np.loadtxt(file_path_txt)
   xyz = data[:, :3]   #只有x,y,z数据有用.

2. 判断点是否在圆柱内部:  get_pc_mask_inside_cylinder_org

3. clip_cyn: 遍历每个圆柱，做clipping (只保留bbox内部的圆柱)。核心函数是下面的_clip.
'''    

#p0, p1: start and end point of a cyn.
#mn = [xmin, ymin, zmin], mx = [xmax, ymax, zmax], the bbox information.
#calling: res = _clip(np.asarray(cyn['start']), np.asarray(cyn['end']), mn, mx)
#         if res is not None: clipped_cyn_start, clipped_cyn_end = res
def _clip(p0, p1, mn, mx):
    t0, t1 = 0., 1.
    d = p1 - p0
    for i in range(3):
        if abs(d[i]) < 1e-12:
            if p0[i] < mn[i] or p0[i] > mx[i]: return None
        else:
            inv = 1. / d[i]
            tE = (mn[i] - p0[i]) * inv
            tL = (mx[i] - p0[i]) * inv
            if tE > tL: tE, tL = tL, tE
            t0 = max(t0, tE)
            t1 = min(t1, tL)
            if t0 > t1: return None
    return p0 + t0 * d, p0 + t1 * d

4.def get_pc_mask_inside_cylinder(pts, start, end, radius, len_ext=0.02):
    """

    :param pts: (N, 3)
    :param start: (3,)
    :param end: (3,)
    :param radius:
    :param len_ext: extending length (unit is m), length of the cylinder_plane-1191 used for indices computation is len_cyl + len_ext.
    :return:
        mask_inside: (N,)
    """
    direction = end - start  # Cylinder direction.
    len_cyl = np.linalg.norm(direction)  # Cylinder length.
    direction = direction / len_cyl  # Normalized cylinder_plane-1191 direction.

    if len_cyl < 1e-6:
        mask_inside = np.zeros_like(pts[:, 0], dtype=bool)
        return mask_inside

    # Compute the mask: distance<pc, axis> < radius.
    mask_inside_along_normal = point_to_line_distance_v2(pts, start, end) < radius

    # Compute the mask: pc is between start_ext and end_ext.
    start_ext = start - direction * len_ext  # Extended start.
    end_ext = end + direction * len_ext  # Extended end.
    ES = start_ext - end_ext  # (3,)
    SE = -ES  # (3,)
    SP = pts - start_ext  # (N, 3)
    EP = pts - end_ext  # (N, 3)
    mask_inside_along_direction = (np.sum(SP * SE, axis=1) > 0) & (np.sum(EP * ES, axis=1) > 0)

    mask_inside = mask_inside_along_normal & mask_inside_along_direction
    return mask_inside
