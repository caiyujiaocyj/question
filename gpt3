"""
http://109.105.4.120/books/pers-mengchuan/page/visualization-tool

python visualize_20251111.py --dir_root exp/NRDK/baseline_s2/cascade_result_seg_baseline_s1/ --rel_dir_fitted cylinder_fitting_mcwei_20251020
"""
import copy
import numpy as np
import os
import pickle
import glob
from tqdm import tqdm
import argparse
import open3d as o3d


LST_COLOR = [[0.6, 0.6, 0.6]] + [np.random.rand(3).tolist() for _ in range(100000)] + [[0, 0, 0]]
THR_NUM_PTS_VALID = 10



def parse_args():
    parser = argparse.ArgumentParser(description='')
    parser.add_argument('--dir_root',
                        default='data',
                        # default='exp/NRDK/baseline_s2/result_gt_seg',
                        type=str, help='')
    parser.add_argument('--rel_dir_fitted', type=str, default='cylinder_fitting_cyj', help='')
    args = parser.parse_args()
    args.dir_fitted = os.path.join(args.dir_root, args.rel_dir_fitted)
    args.dir_save_for_vis = os.path.join(args.dir_root, args.rel_dir_fitted, 'save_for_vis')
    return args


def point_to_line_distance_v2(pts, A, B):
    """

    :param pts: (N, 3)
    :param A: (3,)
    :param B: (3,)
    :return: (N,)
    """
    A = np.array(A)
    B = np.array(B)
    AB = B - A
    if np.linalg.norm(AB) < 1e-10:
        return np.linalg.norm(pts - A, axis=1)
    AP = pts - A
    cross_product = np.cross(AP, AB)
    cross_norm = np.linalg.norm(cross_product, axis=1)

    dis = cross_norm / np.linalg.norm(AB)
    return dis


def get_pc_mask_inside_cylinder(pts, start, end, radius, len_ext=0.02):
    """

    :param pts: (N, 3)
    :param start: (3,)
    :param end: (3,)
    :param radius:
    :param len_ext: extending length (unit is m), length of the cylinder used for indices computation is len_cyl + len_ext.
    :return:
        mask_inside: (N,)
    """
    direction = end - start  # Cylinder direction.
    len_cyl = np.linalg.norm(direction)  # Cylinder length.
    direction = direction / len_cyl  # Normalized cylinder direction.

    if len_cyl < 1e-6:
        mask_inside = np.zeros_like(pts[:, 0], dtype=bool)
        return mask_inside

    # Compute the mask: distance<pc, axis> < radius.
    mask_inside_along_normal = point_to_line_distance_v2(pts, start, end) < radius

    # Compute the mask: pc is between start_ext and end_ext.
    start_ext = start - direction * len_ext  # Extended start.
    end_ext = end + direction * len_ext  # Extended end.
    ES = start_ext - end_ext  # (3,)
    SE = -ES  # (3,)
    SP = pts - start_ext  # (N, 3)
    EP = pts - end_ext  # (N, 3)
    mask_inside_along_direction = (np.sum(SP * SE, axis=1) > 0) & (np.sum(EP * ES, axis=1) > 0)

    mask_inside = mask_inside_along_normal & mask_inside_along_direction
    return mask_inside


def vis_single_block(path_pc, args):
    dir_fitted = args.dir_fitted  # useless
    dir_save_for_vis = args.dir_save_for_vis
    dir_vis = dir_save_for_vis.replace('save_for_vis', 'vis')
    name = os.path.basename(path_pc).replace('pkl', '')

    res_fitting = pickle.load(open(os.path.join(dir_save_for_vis, f'{os.path.basename(path_pc)}.pkl'), 'rb'))
    """
    Outputs of components fitting.
    res_fitting is a dict, 
    res_fitting['ind_pts'] is a point indice. pc[res_fitting['ind_pts']] is the input points of component fitting.
    res_fitting['results'] is the component fitting result. It is a list.
    res_fitting['ind_pts'][i] is the information of a fitted cylinder.
    res_fitting['ind_pts'][i]['ind_clustered'] is the point indice of a cluster. Use it to index pc[res_fitting['ind_pts']].
    res_fitting['ind_pts'][i]['ind_inlier'] is the inlier point indice.  Use it to index pc[res_fitting['ind_pts']].
    res_fitting['ind_pts'][i]['d'] is the estimated pipe direction (for all points) using predicted normals.
    res_fitting['ind_pts'][i]['start'] 
    res_fitting['ind_pts'][i]['end']
    res_fitting['ind_pts'][i]['radius']
    res_fitting['ind_pts'][i]['length']
    """
    res_eval = pickle.load(open(os.path.join(dir_save_for_vis, f'eval_{os.path.basename(path_pc)}.pkl'), 'rb'))
    """
    Matching results during evaluation.
    res_eval['gt']: Cropped GT cylinders by a 3x3x3 block. A list.
        res_eval['gt'][i] is the ith cropped GT cylinder. A dict, keys are 'start', 'end', 'radius'.
    res_eval['up']: Indices of the unmatched predicted cylinders (FP). A list.
    res_eval['ug']: Indices of the unmatched GT cylinders (FN). A list.
    res_eval['m']: The matched index pairs. A list, each element is a two-tuple.
        res_eval['m'][0] is the index of a matched predicted cylinder.
        res_eval['m'][1] is the index of a matched GT cylinder.
    """

    gt = res_eval['gt']
    lst_idx_pred_unmatched = res_eval['up']
    lst_idx_gt_unmatched = res_eval['ug']
    lst_pair = res_eval['m']

    recall = (len(gt) - len(lst_idx_gt_unmatched)) / (len(gt) + 1e-6)
    print(f'{path_pc}: gt = {len(gt)}, fn = {len(lst_idx_gt_unmatched)}, recall = {round(recall, 3)}')

    # 没有 FN，不需要看。
    if not lst_idx_gt_unmatched:
        return

    pc = np.loadtxt(path_pc)
    """
    Input points of components fitting, also the semantic segmentation prediction results.
    shape is (n, 17)
        pts = pc[:, :3]
        normals = pc[:, 3:6], normals prediction for each point.
        direction = pc[:, 6:9], original direction prediction for each point, but it is useless, we use the estimated direction based on normals prediction.
        radii = pc[:, 9], radius prediction for each point.
        cls = pc[:, 10], GT semantic label, -1: ignore, 0: non-pipe, 1: pipe.
        Others: Useless.
    """

    ind_pc = res_fitting['ind_pts']  # point indices in pc
    pc = pc[ind_pc]  # down-sampled points
    pc = pc[pc[:, 10] == 1]  # pipe points

    # Get the point indices around all unmatched GT cylinders.
    mask_pc_fn = np.zeros_like(pc[:, 0], dtype=bool)
    lst_idx_gt_unmatched_valid = []  # 点数比较多的 FN 索引列表
    for idx_gt in lst_idx_gt_unmatched:
        cyl = res_eval['gt'][idx_gt]
        mask_i = get_pc_mask_inside_cylinder(pc[:, :3], cyl['start'], cyl['end'], cyl['radius'] + 0.02, len_ext=0.02)
        # 如果 FN pipe 对应的点很少，也可以先不看。我们可以优先关注点比较多但是漏检的情况。
        if sum(mask_i) > THR_NUM_PTS_VALID:
            lst_idx_gt_unmatched_valid.append(idx_gt)
        mask_pc_fn |= mask_i
    ind_pc_fn = mask_pc_fn.nonzero()[0]  # The point indices around all unmatched GT cylinders.

    # 加一些条件，如果 FN pipe 对应的点很少，也可以先不看。我们可以优先关注点比较多但是漏检的情况。
    if not lst_idx_gt_unmatched_valid:
        return
    lst_gt_fn = [gt[idx_gt] for idx_gt in lst_idx_gt_unmatched_valid]
    print (lst_idx_gt_unmatched_valid)
    """
    Unmatched Cropped GT cylinders (FN). A list. lst_gt_fn[i] is the ith unmatched cropped GT cylinder.
    """

    pc_fitted = copy.deepcopy(pc)
    pc_fitted[:, 11] = -1
    pc_fitted[:, 12] = -1
    lst_pred = []
    for i in range(len(res_fitting['results'])):
        ind_clustered = res_fitting['results'][i]['ind_clustered']
        ind_inlier = res_fitting['results'][i]['ind_inlier']
        assert len(np.setdiff1d(ind_inlier, ind_clustered)) == 0
        d = res_fitting['results'][i]['d']
        start = res_fitting['results'][i]['start']
        end = res_fitting['results'][i]['end']
        radius = res_fitting['results'][i]['radius']
        cyl = dict(start=start, end=end, radius=radius)
        length = res_fitting['results'][i]['length']
        pc_fitted[ind_clustered, 11] = i + 1  # 11: cluster id
        pc_fitted[ind_inlier, 12] = i  # 12: inlier id
        pc[:, 6:9] = d
        # Filter pred by fn pts.
        if len(np.intersect1d(ind_pc_fn, ind_inlier)):
            cyl['id'] = i + 1
            lst_pred.append(cyl)

    # Input of component fitting.
    pc_fn = pc[mask_pc_fn]
    pcd = dict(
        pts=pc_fn[:, :3],
        id=pc_fn[:, 10],  # GT semantic ID, all the values are 1, which means pipe points.
        direct=pc_fn[:, 6:9],  # Estimated pipe direction (for all points) using predicted normals.
        normals=pc_fn[:, 3:6],  # The predicted normals.
    )

    # Output of component fitting.
    pc_fitted_fn = pc_fitted[mask_pc_fn]
    pcd_fitted = dict(
        pts=pc_fitted_fn[:, :3],
        id=pc_fitted_fn[:, 11],  # The cluster id.
        id_inlier=pc_fitted_fn[:, 12],  # The inlier id of RANSAC.
    )

    path_vis = os.path.join(dir_vis, f'{name}.png')
    # vis_compare_2_pc(vis_custom, [pcd_fitted, lst_pred], [pcd_fitted, []], path_vis)  # 切换：1. pred cylinders + clustered PCs, 2. clustered PCs.
    vis_compare_2_pc(vis_custom, [pcd_fitted, lst_pred], [pcd, lst_gt_fn], path_vis)  # 切换：1. pred cylinders + clustered PCs, 2. FN cylinders + PCs around FN cylinders.
    return


def vis_custom(data, vis):
    pcd, lst_param = data
    pts = pcd['pts']
    id = pcd['id']
    id_inlier = pcd.get('id_inlier', id)
    direct = pcd.get('direct', None)
    normals = pcd.get('normals', None)

    for id_ins in np.unique(id[:, ]):
        i_color = int(id_ins)
        color = LST_COLOR[i_color + 1]
        pcd = o3d.geometry.PointCloud()
        pcd.points = o3d.utility.Vector3dVector(pts[id == id_ins])
        pcd.paint_uniform_color(color)
        vis.add_geometry(pcd)

    for param in lst_param:
        if param is None:
            continue
        if ('radius' in param):
            add_cylinder(vis, param, color=LST_COLOR[param.get('id', 1) + 1])
    return


def create_cylinder_line(start, end, radius=0.001, color=[1, 0, 0]):
    """
    创建一条圆柱体线段

    参数:
    start: 起点
    end: 终点
    radius: 圆柱半径（线宽）
    color: 颜色

    返回:
    cylinder: 圆柱体网格
    """
    # 计算线段方向和长度
    direction = np.subtract(end, start)
    length = np.linalg.norm(direction)
    if length < 1e-6:
        return None

    direction_unit = direction / length

    # 创建圆柱体
    cylinder = o3d.geometry.TriangleMesh.create_cylinder(
        radius=radius,
        height=length,
        resolution=4
    )

    # 计算旋转矩阵
    z_axis = np.array([0, 0, 1])
    rotation_axis = np.cross(z_axis, direction_unit)
    rotation_angle = np.arccos(np.dot(z_axis, direction_unit))

    if np.linalg.norm(rotation_axis) > 1e-6:
        rotation_axis = rotation_axis / np.linalg.norm(rotation_axis)
        rotation_matrix = o3d.geometry.get_rotation_matrix_from_axis_angle(rotation_axis * rotation_angle)
        cylinder.rotate(rotation_matrix, center=(0, 0, 0))

    # 平移圆柱体到正确位置
    cylinder.translate(np.mean([start, end], axis=0))
    cylinder.paint_uniform_color(color)
    return cylinder


def add_cylinder(vis, cyl, color, transparent=False, line_radius=0.002):
    """
    使用圆柱体表示所有线段来绘制圆柱

    参数:
    vis: Open3D 可视化器
    cyl: 圆柱参数，可以是字典或列表
    color: 颜色
    transparent: 是否透明
    line_radius: 线段的半径（粗细）
    """
    if isinstance(cyl, dict):
        start = np.array(cyl['start'])
        end = np.array(cyl['end'])
        radius = cyl['radius']
    elif isinstance(cyl, list):
        start = np.array(cyl[0])
        end = np.array(cyl[1])
        radius = cyl[2]
    else:
        raise TypeError(type(cyl))

    # start = global2local(start)
    # end = global2local(end)

    v = end - start
    height = np.linalg.norm(v)
    if height < 1e-6:
        print(f"Cylinder has zero height, skipped.")
        return
    v_unit = v / height

    # 1. 绘制圆柱中心线（使用圆柱体）
    center_line = create_cylinder_line(start, end, radius=line_radius, color=color)
    vis.add_geometry(center_line)

    # 2. 找到两个互相垂直且都垂直于轴线的向量
    if abs(v_unit[0]) > 0.5:
        u = np.cross(v_unit, [0, 1, 0])
    else:
        u = np.cross(v_unit, [1, 0, 0])
    u = u / np.linalg.norm(u)
    w = np.cross(v_unit, u)
    w = w / np.linalg.norm(w)

    # 3. 创建顶面和底面圆形（使用圆柱体线段）
    num_segments = 16  # 使用4个点表示正方形
    angles = np.linspace(0, 2 * np.pi, num_segments, endpoint=False)

    # 顶面点
    top_points = []
    for angle in angles:
        point = start + radius * (np.cos(angle) * u + np.sin(angle) * w)
        top_points.append(point)

    # 底面点
    bottom_points = []
    for angle in angles:
        point = end + radius * (np.cos(angle) * u + np.sin(angle) * w)
        bottom_points.append(point)

    # 4. 绘制顶面和底面（使用圆柱体线段）
    for i in range(num_segments):
        # 顶面的边
        top_edge = create_cylinder_line(
            top_points[i],
            top_points[(i + 1) % num_segments],
            radius=line_radius,
            color=color
        )
        vis.add_geometry(top_edge)

        # 底面的边
        bottom_edge = create_cylinder_line(
            bottom_points[i],
            bottom_points[(i + 1) % num_segments],
            radius=line_radius,
            color=color
        )
        vis.add_geometry(bottom_edge)

    # 5. 绘制四条与中心线平行的边（母线）
    for i in range(0, num_segments, 2):
        # 使用线段
        edge_points = [top_points[i], bottom_points[i]]
        edge_lines = [[0, 1]]
        edge = o3d.geometry.LineSet()
        edge.points = o3d.utility.Vector3dVector(edge_points)
        edge.lines = o3d.utility.Vector2iVector(edge_lines)
        edge.paint_uniform_color(color)

        # 使用圆柱体
        # edge = create_cylinder_line(
        #     top_points[i],
        #     bottom_points[i],
        #     radius=line_radius,
        #     color=color
        # )
        vis.add_geometry(edge)
    return


def vis_compare_2_pc(func_vis, lst_data1, lst_data2, path_save_base, custom_keys_for_save=('A', 'S', 'D'), full_screen=False):
    """
    Press 'T' to switch between two data.
    Press 'S' to save visualization results of two data as PNGs.
    Press 'Esc' to close current visualization and check next block.
    :param lst_data1: is a list.
        # lst_data1[i][0] is PC, shape is (n, 13).
        # lst_data1[i][1] is the param with type of dict. For pipe, keys are 'start', 'end', 'radius'.
    :param lst_data2: same as lst_data1.
    :param path_save_base:
    :return:
    """

    def toggle_cloud(vis):
        current_view = vis.get_view_control().convert_to_pinhole_camera_parameters()
        global show_1st
        show_1st = not show_1st
        vis.clear_geometries()
        if show_1st:
            func_vis(lst_data1, vis)
        else:
            func_vis(lst_data2, vis)
        # reset_view(vis)  # 保持视角一致
        vis.get_view_control().convert_from_pinhole_camera_parameters(current_view)
        vis.update_renderer()
        return True

    def custom_save_screenshot(k):
        def callback(vis):
            global show_1st
            suffix = '_correct' if show_1st else '_origin'
            path_save = path_save_base.replace('.png', '') + f'{suffix}.png'
            path_save = os.path.join(os.path.dirname(path_save), f'{k}_{os.path.basename(path_save)}')
            vis.capture_screen_image(path_save)

            if lst_data2 is None:
                assert 1 == 2

            current_view = vis.get_view_control().convert_to_pinhole_camera_parameters()
            vis.clear_geometries()
            show_1st = not show_1st
            if show_1st:
                func_vis(lst_data1, vis)
            else:
                func_vis(lst_data2, vis)
            # reset_view(vis)  # 保持视角一致
            vis.get_view_control().convert_from_pinhole_camera_parameters(current_view)
            vis.poll_events()
            vis.update_renderer()

            suffix = '_correct' if suffix == '_origin' else '_origin'
            path_save = path_save_base.replace('.png', '') + f'{suffix}.png'
            path_save = os.path.join(os.path.dirname(path_save), f'{k}_{os.path.basename(path_save)}')
            vis.capture_screen_image(path_save)
            vis.destroy_window()
            assert 1 == 2
            return True
        return callback

    try:
        # 初始化窗口
        vis = o3d.visualization.VisualizerWithKeyCallback()
        if full_screen:
            vis.create_window(window_name=os.path.basename(path_save_base).replace('.png', ''))
        else:
            vis.create_window(width=800, height=800, window_name=os.path.basename(path_save_base).replace('.png', ''))
        os.makedirs(os.path.dirname(path_save_base), exist_ok=True)
        global show_1st
        show_1st = True
        func_vis(lst_data1, vis)
        initial_view = vis.get_view_control().convert_to_pinhole_camera_parameters()

        # 注册按键（T键切换）
        if lst_data2 is not None:
            vis.register_key_callback(ord("T"), toggle_cloud)

        for key in custom_keys_for_save:
            vis.register_key_callback(ord(key), custom_save_screenshot(key))

        # 运行交互
        # print("按 T 键切换红/蓝点云")
        vis.run()
    except Exception as e:
        print(e)


def main(args):
    dir_root = args.dir_root

    lst_path_pc = glob.glob(os.path.join(dir_root, "*.pts"))
    print(f"找到 {len(lst_path_pc)} 个点云文件:")
    # lst_path_pc = [
    #     'exp/NRDK/baseline_s2/result_gt_seg/block_1Ftest_11_7_2.pts',
    #     'exp/NRDK/baseline_s2/result_gt_seg/block_1Ftest_11_7_2.pts',
    #     'exp/NRDK/baseline_s2/result_gt_seg/block_1Ftest_11_7_2.pts',
    #     'exp/NRDK/baseline_s2/result_gt_seg/block_1Ftest_11_7_2.pts',
    #     'exp/NRDK/baseline_s2/result_gt_seg/block_1Ftest_11_7_2.pts',
    # ]
    for i, path_pc in enumerate(lst_path_pc):
        print(f'visualize: {i}')
        vis_single_block(path_pc, args)
    return


if __name__ == '__main__':
    main(parse_args())
