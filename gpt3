#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
GUI 版本可视化（Open3D 0.19+）
保留原线段构成的柱体绘制方式，增加 GUI 标签显示。
"""

import numpy as np
import open3d as o3d
import open3d.visualization.gui as gui
import open3d.visualization.rendering as rendering
import copy
import argparse
import os
import pickle
import glob
from tqdm import tqdm

LST_COLOR = [[0.6, 0.6, 0.6]] + [np.random.rand(3).tolist() for _ in range(100000)] + [[0, 0, 0]]
THR_NUM_PTS_VALID = 10


# =============== 原逻辑部分：构造线段圆柱体 ===============
def create_cylinder_line(start, end, radius=0.001, color=[1, 0, 0]):
    direction = np.subtract(end, start)
    length = np.linalg.norm(direction)
    if length < 1e-6:
        return None

    direction_unit = direction / length
    cylinder = o3d.geometry.TriangleMesh.create_cylinder(radius=radius, height=length, resolution=4)

    z_axis = np.array([0, 0, 1])
    rotation_axis = np.cross(z_axis, direction_unit)
    rotation_angle = np.arccos(np.dot(z_axis, direction_unit))

    if np.linalg.norm(rotation_axis) > 1e-6:
        rotation_axis = rotation_axis / np.linalg.norm(rotation_axis)
        rotation_matrix = o3d.geometry.get_rotation_matrix_from_axis_angle(rotation_axis * rotation_angle)
        cylinder.rotate(rotation_matrix, center=(0, 0, 0))

    cylinder.translate(np.mean([start, end], axis=0))
    cylinder.paint_uniform_color(color)
    return cylinder


def add_cylinder_lines(cyl, color):
    """
    构造一根线段风格的圆柱体（返回几何列表）。
    """
    geometries = []

    if isinstance(cyl, dict):
        start = np.array(cyl['start'])
        end = np.array(cyl['end'])
        radius = cyl['radius']
    elif isinstance(cyl, list):
        start = np.array(cyl[0])
        end = np.array(cyl[1])
        radius = cyl[2]
    else:
        raise TypeError(type(cyl))

    v = end - start
    height = np.linalg.norm(v)
    if height < 1e-6:
        return geometries
    v_unit = v / height

    center_line = create_cylinder_line(start, end, radius=0.002, color=color)
    if center_line:
        geometries.append(center_line)

    if abs(v_unit[0]) > 0.5:
        u = np.cross(v_unit, [0, 1, 0])
    else:
        u = np.cross(v_unit, [1, 0, 0])
    u = u / np.linalg.norm(u)
    w = np.cross(v_unit, u)
    w = w / np.linalg.norm(w)

    num_segments = 16
    angles = np.linspace(0, 2 * np.pi, num_segments, endpoint=False)
    top_points = [start + radius * (np.cos(a) * u + np.sin(a) * w) for a in angles]
    bottom_points = [end + radius * (np.cos(a) * u + np.sin(a) * w) for a in angles]

    for i in range(num_segments):
        top_edge = create_cylinder_line(top_points[i], top_points[(i + 1) % num_segments], radius=0.002, color=color)
        bottom_edge = create_cylinder_line(bottom_points[i], bottom_points[(i + 1) % num_segments], radius=0.002, color=color)
        if top_edge:
            geometries.append(top_edge)
        if bottom_edge:
            geometries.append(bottom_edge)

    for i in range(0, num_segments, 2):
        edge = create_cylinder_line(top_points[i], bottom_points[i], radius=0.002, color=color)
        if edge:
            geometries.append(edge)

    return geometries


# =============== GUI 可视化主逻辑 ===============
def visualize_gui(lst_param):
    app = gui.Application.instance
    app.initialize()

    # 创建窗口和 3D 场景
    window = app.create_window("Open3D GUI Cylinder Visualization", 1280, 960)
    widget3d = gui.SceneWidget()
    widget3d.scene = rendering.Open3DScene(window.renderer)
    widget3d.scene.set_background_color(gui.Color(0.1, 0.1, 0.1))

    mat = rendering.MaterialRecord()
    mat.shader = "defaultUnlit"

    all_geoms = []

    # 添加所有柱体几何体
    for param in lst_param:
        if ('radius' in param):
            color = LST_COLOR[param.get('id', 1) + 1]
            geoms = add_cylinder_lines(param, color=color)
            for g in geoms:
                name = f"cyl_{param.get('id',0)}_{len(all_geoms)}"
                widget3d.scene.add_geometry(name, g, mat)
                all_geoms.append(g)

            # ===== 添加标签 =====
            if 'id' in param:
                start = np.asarray(param['start'], float)
                end = np.asarray(param['end'], float)
                radius = float(param['radius'])
                center = (start + end) / 2.0
                axis = end - start
                n = np.linalg.norm(axis)
                axis_dir = axis / n if n > 1e-6 else np.array([0, 0, 1.0])
                pos = center + axis_dir * (radius + 0.08)
                lbl = widget3d.add_3d_label(pos, f"ID:{param['id']}")
                lbl.color = gui.Color(color[0], color[1], color[2])
                lbl.scale = 1.0

    # 自动相机视角
    bbox = o3d.geometry.AxisAlignedBoundingBox.create_from_points(
        o3d.utility.Vector3dVector(
            np.vstack([np.asarray(g.vertices) for g in all_geoms if isinstance(g, o3d.geometry.TriangleMesh)])
        )
    )
    widget3d.setup_camera(60.0, bbox, bbox.get_center())

    window.add_child(widget3d)
    app.run()


# =============== 示例入口（可改成你的逻辑） ===============
if __name__ == "__main__":
    # 模拟三根柱体
    lst_param = [
        dict(id=1, start=np.array([0, 0, 0]), end=np.array([0, 0, 1]), radius=0.05),
        dict(id=2, start=np.array([0.3, 0.1, 0]), end=np.array([0.3, 0.1, 1.3]), radius=0.04),
        dict(id=3, start=np.array([-0.4, -0.2, 0]), end=np.array([-0.4, -0.2, 0.8]), radius=0.06),
    ]
    visualize_gui(lst_param)