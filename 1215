
"""
主函数：find_cylinder_connection_indices

目标功能：
- 给定两段圆柱轴线（cyn1、cyn2），它们在空间中“垂直相连”（代码默认认为是垂直，不做再判断）
- 在点云 pc 中找出落在“连接区域”内的点索引 idx

核心思路（分步骤）：
1) 先用“线段最近点”求出一个粗略连接中心 center_big，用它做大 AABB 粗筛，减少点数
2) 再把两段轴线当作“无限直线”，求最近点对，取中点作为“假设交点” center_joint
3) 在 center_joint 处建立局部正交坐标系：ex=圆柱1轴向，ey=圆柱2轴向，ez=cross(ex,ey)
4) 在该坐标系下构建两个 OBB（分别沿两个圆柱方向），作为连接区域的细筛盒
5) 细筛得到局部索引，再映射回原始 pc 全局索引输出

返回：
- idx: 落入连接区域的点云全局索引
- center_big: 用于大 AABB 的中心（线段最近点中点）
- center_joint: 假设相交的“交点中心”（无限直线最近点对的中点）
"""

import numpy as np

def _closest_points_on_segments(p1, q1, p2, q2, eps=1e-9):
    """
    计算两条【线段】(p1->q1) 与 (p2->q2) 的最近点对 c1, c2
    - 返回 c1 在线段1上，c2 在线段2上
    - 用于估计两段圆柱轴线“最近接触”的区域中心（做粗筛中心）
    """
    p1 = np.asarray(p1, dtype=float)
    q1 = np.asarray(q1, dtype=float)
    p2 = np.asarray(p2, dtype=float)
    q2 = np.asarray(q2, dtype=float)

    # u, v：两条线段的方向向量
    u = q1 - p1
    v = q2 - p2
    # w0：p1 到 p2 的相对向量
    w0 = p1 - p2

    # 经典最近点对推导里的系数
    a = np.dot(u, u)
    b = np.dot(u, v)
    c = np.dot(v, v)
    d = np.dot(u, w0)
    e = np.dot(v, w0)

    denom = a * c - b * b

    # denom 很小意味着两方向几乎平行/退化：用一个稳定的降级策略
    if denom < eps:
        s = 0.0
        t = -e / c if c > eps else 0.0
    else:
        s = (b * e - c * d) / denom
        t = (a * e - b * d) / denom

    # 线段要求参数落在 [0,1]，把 s,t clamp 回来
    s = max(0.0, min(1.0, s))
    t = max(0.0, min(1.0, t))

    # 最近点对
    c1 = p1 + s * u
    c2 = p2 + t * v
    return c1, c2


def _closest_points_on_lines(p1, d1, p2, d2, eps=1e-12):
    """
    计算两条【无限直线】
      L1: p1 + s*d1
      L2: p2 + t*d2
    的最近点对 c1, c2

    理想相交时：c1 == c2 == 交点
    不相交（异面直线）时：c1,c2 是最短连线的两端点
    """
    p1 = np.asarray(p1, float)
    d1 = np.asarray(d1, float)
    p2 = np.asarray(p2, float)
    d2 = np.asarray(d2, float)

    a = np.dot(d1, d1)
    b = np.dot(d1, d2)
    c = np.dot(d2, d2)
    w0 = p1 - p2
    d = np.dot(d1, w0)
    e = np.dot(d2, w0)

    denom = a * c - b * b

    # 平行/几乎平行时：选一条直线参数 s=0，再解另一条
    if abs(denom) < eps:
        s = 0.0
        t = -e / c if c > eps else 0.0
    else:
        s = (b * e - c * d) / denom
        t = (a * e - b * d) / denom

    c1 = p1 + s * d1
    c2 = p2 + t * d2
    return c1, c2


def _unit(v, eps=1e-12):
    """向量单位化，长度太小则报错。"""
    v = np.asarray(v, float)
    n = np.linalg.norm(v)
    if n < eps:
        raise ValueError("Zero-length direction vector.")
    return v / n


def _obb_mask(points, origin, ex, ey, ez, half_sizes_xyz):
    """
    用 OBB（有向包围盒）做点包含测试，返回布尔 mask

    参数：
    - points: (M,3) 待测试点
    - origin: OBB中心
    - ex/ey/ez: OBB局部坐标系（正交单位基）
    - half_sizes_xyz: [hx,hy,hz] 三轴半边长

    原理：
    - 把点变换到局部坐标系，判断 |x|<=hx 且 |y|<=hy 且 |z|<=hz
    """
    p = points - origin
    x = p @ ex
    y = p @ ey
    z = p @ ez
    hx, hy, hz = half_sizes_xyz
    return (np.abs(x) <= hx) & (np.abs(y) <= hy) & (np.abs(z) <= hz)


def _dist_to_nearest_endpoint(point, start, end):
    """
    点到线段两个端点的距离，取较小者：
    - 用在“交点中心”到圆柱端点的最近距离估计
    - 以决定 OBB 沿轴向需要覆盖多长
    """
    point = np.asarray(point, float)
    start = np.asarray(start, float)
    end = np.asarray(end, float)
    return min(np.linalg.norm(point - start), np.linalg.norm(point - end))


def find_cylinder_connection_indices(
    cyn1, cyn2, pc,
    bbox_half_size,   # 大AABB半边长（粗筛用）
    margin=0.0        # 可选余量（给筛选区域留冗余）
):
    """
    输入：
    - cyn1/cyn2: {start,end,radius}
      start/end: (3,) 圆柱轴线线段端点
      radius: 半径
    - pc: (N,3) 点云
    - bbox_half_size: 大AABB半边长（标量或3元向量）
    - margin: 余量

    输出：
    - idx: 原始 pc 的全局索引（落在连接区域内）
    - center_big: 粗筛中心
    - center_joint: 假设相交的“交点中心”
    """
    pc = np.asarray(pc, dtype=float)

    # ---------------- Step 0: 解析输入 ----------------
    p1 = np.asarray(cyn1["start"], dtype=float)
    q1 = np.asarray(cyn1["end"], dtype=float)
    p2 = np.asarray(cyn2["start"], dtype=float)
    q2 = np.asarray(cyn2["end"], dtype=float)

    r1 = float(cyn1["radius"])
    r2 = float(cyn2["radius"])

    # ---------------- Step 1: 用线段最近点求粗筛中心 center_big ----------------
    # 目的：即使两圆柱不严格相交，也能找到它们空间最近处的区域中心
    cseg1, cseg2 = _closest_points_on_segments(p1, q1, p2, q2)
    center_big = (cseg1 + cseg2) / 2.0

    # ---------------- Step 2: 大AABB粗筛（减少点数量） ----------------
    # bbox_half_size 支持标量（各向同性）或三轴不同半边长
    bbox_half_size = np.asarray(
        [bbox_half_size] * 3 if np.isscalar(bbox_half_size) else bbox_half_size,
        dtype=float
    )
    min_corner = center_big - bbox_half_size
    max_corner = center_big + bbox_half_size

    # inside_big：pc 中落在该 AABB 内的点
    inside_big = np.all((pc >= min_corner) & (pc <= max_corner), axis=1)
    idx_big = np.where(inside_big)[0]  # 全局索引
    if idx_big.size == 0:
        # 粗筛都没有点，直接返回
        return idx_big, center_big, None

    pc_big = pc[idx_big]  # 粗筛后的子点云

    # ---------------- Step 3: 把轴线当作无限直线求“交点中心” center_joint ----------------
    # 说明：两条轴线理想垂直相交时，这里得到真实交点；
    # 若是异面/不完全相交，则取最近点对中点作为“连接关节中心”
    d1 = q1 - p1
    d2 = q2 - p2
    cl1, cl2 = _closest_points_on_lines(p1, d1, p2, d2)
    center_joint = (cl1 + cl2) / 2.0

    # ---------------- Step 4: 建立局部坐标系 (ex,ey,ez) ----------------
    # ex：沿圆柱1轴线方向
    # ey：沿圆柱2轴线方向
    # ez：两者叉乘方向（垂直于 ex,ey 的法向）
    ex = _unit(d1)
    ey = _unit(d2)
    ez = _unit(np.cross(ex, ey))  # 代码默认认为垂直，不做退化判断

    # ---------------- Step 5: 构建两个 OBB 作为细筛“连接区域” ----------------
    # 思想：连接处像两个互相插接/靠近的局部块：
    # - 对圆柱1，沿 ex 方向给足够长度覆盖到最近端点，并额外加上另一个圆柱半径 r2（表示“能连接到对方”）
    # - 截面方向（y,z）用本圆柱半径 r1
    #
    # OBB1（以圆柱1为主的连接区域）
    hx1 = _dist_to_nearest_endpoint(center_joint, p1, q1) + r2 + margin
    hy1 = r1 + margin
    hz1 = r1 + margin
    mask1 = _obb_mask(
        pc_big,
        origin=center_joint,
        ex=ex, ey=ey, ez=ez,
        half_sizes_xyz=np.array([hx1, hy1, hz1], dtype=float)
    )

    # OBB2（以圆柱2为主的连接区域）
    # 对圆柱2，沿 ey 方向加长到最近端点，并额外加上 r1
    hy2 = _dist_to_nearest_endpoint(center_joint, p2, q2) + r1 + margin
    hx2 = r2 + margin
    hz2 = r2 + margin
    mask2 = _obb_mask(
        pc_big,
        origin=center_joint,
        ex=ex, ey=ey, ez=ez,
        half_sizes_xyz=np.array([hx2, hy2, hz2], dtype=float)
    )

    # ---------------- Step 6: 合并细筛结果，映射回原始点云索引 ----------------
    sel_local = np.where(mask1 | mask2)[0]  # 在 pc_big 里的局部索引
    idx = idx_big[sel_local]                # 转成原始 pc 的全局索引

    return idx, center_big, center_joint


if __name__ == "__main__":
    cyn1 = {"start": [0, 0, 0],   "end": [0, 0, 1],   "radius": 0.05}
    cyn2 = {"start": [0, 0, 0.5], "end": [1, 0, 0.5], "radius": 0.05}

    pc = np.random.rand(10000, 3)

    idx, center_big, center_joint = find_cylinder_connection_indices(
        cyn1, cyn2, pc, bbox_half_size=0.2, margin=0.005
    )

    print("center_big:", center_big)
    print("center_joint:", center_joint)
    print("count:", len(idx))
    print("idx[:10]:", idx[:10])