"""
 主函数 find_cylinder_connection_indices(cyn1, cyn2, pc, bbox_half_size)
   根据两根柱体和点云，返回柱体垂直连接区域附近的点云索引。
    """

import numpy as np

def _closest_points_on_segments(p1, q1, p2, q2, eps=1e-9):
    """
    计算两条线段 P1Q1 和 P2Q2 间的最近点 C1, C2
    返回:
        C1: 在线段1上的最近点 (3,)
        C2: 在线段2上的最近点 (3,)
    """
    p1 = np.asarray(p1, dtype=float)
    q1 = np.asarray(q1, dtype=float)
    p2 = np.asarray(p2, dtype=float)
    q2 = np.asarray(q2, dtype=float)

    u = q1 - p1  # cyn1方向
    v = q2 - p2  # cyn2方向
    w0 = p1 - p2

    a = np.dot(u, u)  # |u|^2
    b = np.dot(u, v)
    c = np.dot(v, v)  # |v|^2
    d = np.dot(u, w0)
    e = np.dot(v, w0)

    denom = a * c - b * b  # 行列式

    # s, t 是参数，表示 C1 = p1 + s*u, C2 = p2 + t*v, s,t∈[0,1]
    if denom < eps:
        # 近似平行，退化处理：固定 s，求t最小化距离
        s = 0.0
        t = -e / c if c > eps else 0.0
    else:
        s = (b * e - c * d) / denom
        t = (a * e - b * d) / denom

    # clamp 到 [0,1] 保证在“线段”上
    s = max(0.0, min(1.0, s))
    t = max(0.0, min(1.0, t))

    c1 = p1 + s * u
    c2 = p2 + t * v
    return c1, c2


def find_cylinder_connection_indices(cyn1, cyn2, pc, bbox_half_size):
    """
    根据两根柱体和点云，返回柱体垂直连接区域附近的点云索引。

    参数：
        cyn1, cyn2: dict
            包含键 'start', 'end', 'radius'，其中
            - 'start' 和 'end' 为 (3,) 数组或列表，表示柱体轴线两端点
            - 'radius' 为半径（这里不直接用，只用于语义完整）
        pc: ndarray, shape (N, 3)
            点云坐标
        bbox_half_size: float 或 长度为 3 的 array-like
            以连接区域中心为原点的包围盒半边长：
            - 若是标量 b，则在 x/y/z 上都用 [-b, b]
            - 若是 3 维向量 [bx, by, bz]，则分别是三方向半边长

    返回：
        idx: ndarray (M,)
            落在包围盒内的点云索引
        center: ndarray (3,)
            估计的柱体连接中心点（两轴最近点的中点）
    """
    pc = np.asarray(pc, dtype=float)

    # 取出线段端点
    p1 = np.asarray(cyn1["start"], dtype=float)
    q1 = np.asarray(cyn1["end"], dtype=float)
    p2 = np.asarray(cyn2["start"], dtype=float)
    q2 = np.asarray(cyn2["end"], dtype=float)

    # 求线段间最近点对
    c1, c2 = _closest_points_on_segments(p1, q1, p2, q2)

    # 连接区域中心
    center = (c1 + c2) / 2.0

    # 生成 BBox 半边长
    bbox_half_size = np.asarray(
        [bbox_half_size] * 3 if np.isscalar(bbox_half_size) else bbox_half_size,
        dtype=float
    )

    # 构造 AABB
    min_corner = center - bbox_half_size
    max_corner = center + bbox_half_size

    # 过滤点云
    inside = np.all((pc >= min_corner) & (pc <= max_corner), axis=1)
    idx = np.where(inside)[0]

    return idx, center

if __name__ == "__main__":
    cyn1 = {
        "start": [0, 0, 0],
        "end": [0, 0, 1],
        "radius": 0.05
    }

    cyn2 = {
        "start": [0, 0, 0.5],
        "end": [1, 0, 0.5],
        "radius": 0.05
    }

    pc = np.random.rand(10000, 3)
    idx, center = find_cylinder_connection_indices(cyn1, cyn2, pc, bbox_half_size=0.1)

    print("连接中心：", center)
    print("连接区域点云数量：", len(idx))
    print("前几个索引：", idx[:10])
