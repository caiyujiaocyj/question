
import numpy as np

def _closest_points_on_segments(p1, q1, p2, q2, eps=1e-9):
    p1 = np.asarray(p1, dtype=float)
    q1 = np.asarray(q1, dtype=float)
    p2 = np.asarray(p2, dtype=float)
    q2 = np.asarray(q2, dtype=float)

    u = q1 - p1
    v = q2 - p2
    w0 = p1 - p2

    a = np.dot(u, u)
    b = np.dot(u, v)
    c = np.dot(v, v)
    d = np.dot(u, w0)
    e = np.dot(v, w0)

    denom = a * c - b * b
    if denom < eps:
        s = 0.0
        t = -e / c if c > eps else 0.0
    else:
        s = (b * e - c * d) / denom
        t = (a * e - b * d) / denom

    s = max(0.0, min(1.0, s))
    t = max(0.0, min(1.0, t))

    c1 = p1 + s * u
    c2 = p2 + t * v
    return c1, c2

def _unit(v, eps=1e-12):
    v = np.asarray(v, float)
    n = np.linalg.norm(v)
    if n < eps:
        raise ValueError("Zero-length vector.")
    return v / n

def _obb_mask(points, origin, ex, ey, ez, half_sizes_xyz):
    p = points - origin
    x = p @ ex
    y = p @ ey
    z = p @ ez
    hx, hy, hz = half_sizes_xyz
    return (np.abs(x) <= hx) & (np.abs(y) <= hy) & (np.abs(z) <= hz)

def find_cylinder_connection_indices(
    cyn1, cyn2, pc,
    bbox_half_size,          # 粗筛AABB半边长
    joint_len=None,          # 连接处沿轴向截取的半长度(可选)，None则用(c1,c2,center)自动
    margin=0.0               # 余量，防止过紧（比如0.005）
):
    """
    目的：找两个垂直且连接柱体的连接处区域点云索引

    返回：
      idx: 连接处区域点索引
      center: (c1+c2)/2
      c1, c2: 最近点对
    """
    pc = np.asarray(pc, dtype=float)

    p1 = np.asarray(cyn1["start"], float)
    q1 = np.asarray(cyn1["end"], float)
    p2 = np.asarray(cyn2["start"], float)
    q2 = np.asarray(cyn2["end"], float)
    r1 = float(cyn1["radius"])
    r2 = float(cyn2["radius"])

    # 最近点对 + 连接中心
    c1, c2 = _closest_points_on_segments(p1, q1, p2, q2)
    center = (c1 + c2) / 2.0

    # 1) 大AABB粗筛
    bbox_half_size = np.asarray(
        [bbox_half_size] * 3 if np.isscalar(bbox_half_size) else bbox_half_size,
        dtype=float
    )
    min_corner = center - bbox_half_size
    max_corner = center + bbox_half_size
    inside_big = np.all((pc >= min_corner) & (pc <= max_corner), axis=1)
    idx_big = np.where(inside_big)[0]
    if idx_big.size == 0:
        return idx_big, center, c1, c2
    pc_big = pc[idx_big]

    # 2) 连接处局部坐标系：x=柱1轴，y=柱2轴，z=cross
    ex = _unit(q1 - p1)
    ey = _unit(q2 - p2)
    ez = _unit(np.cross(ex, ey))  # 默认垂直连接，不再做判断

    # 3) 连接处“轴向截取长度”
    # 如果你希望固定截取，比如连接处前后各 2*半径，可传 joint_len=2*r1 或 2*r2 等
    if joint_len is None:
        # 自动：用 c1/c2 到 center 的轴向投影长度（通常≈0，但对拟合误差也稳）
        hx1 = abs(np.dot(center - c1, ex)) + (2*r1) + margin
        hy2 = abs(np.dot(center - c2, ey)) + (2*r2) + margin
    else:
        hx1 = float(joint_len) + margin
        hy2 = float(joint_len) + margin

    # 4) 两个小OBB并集 = 十字连接处
    # OBB1（以c1为原点）：沿x截取一段；横向用另一根柱的半径；z用本柱半径
    mask1 = _obb_mask(
        pc_big, origin=c1, ex=ex, ey=ey, ez=ez,
        half_sizes_xyz=np.array([hx1, r2 + margin, r1 + margin])
    )
    # OBB2（以c2为原点）：沿y截取一段；横向用另一根柱的半径；z用本柱半径
    mask2 = _obb_mask(
        pc_big, origin=c2, ex=ex, ey=ey, ez=ez,
        half_sizes_xyz=np.array([r1 + margin, hy2, r2 + margin])
    )

    idx = idx_big[np.where(mask1 | mask2)[0]]
    return idx, center, c1, c2