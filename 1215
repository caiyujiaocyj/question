"""
    主函数 find_cylinder_connection_indices
   功能：
   - 两段垂直圆柱（cyn1、cyn2）相连
   - 在点云 pc 中找出落在“连接区域”内的点索引 idx

   - 返回：
      idx: 原始 pc 的全局索引
      center_big: 用于大AABB的中心（线段最近点中点）
      center_joint: “假设相交”的交点中心（无限直线的交汇点）
   """
import numpy as np

def _closest_points_on_segments(p1, q1, p2, q2, eps=1e-9):
    p1 = np.asarray(p1, dtype=float)
    q1 = np.asarray(q1, dtype=float)
    p2 = np.asarray(p2, dtype=float)
    q2 = np.asarray(q2, dtype=float)

    u = q1 - p1
    v = q2 - p2
    w0 = p1 - p2

    a = np.dot(u, u)
    b = np.dot(u, v)
    c = np.dot(v, v)
    d = np.dot(u, w0)
    e = np.dot(v, w0)

    denom = a * c - b * b
    if denom < eps:
        s = 0.0
        t = -e / c if c > eps else 0.0
    else:
        s = (b * e - c * d) / denom
        t = (a * e - b * d) / denom

    s = max(0.0, min(1.0, s))
    t = max(0.0, min(1.0, t))

    c1 = p1 + s * u
    c2 = p2 + t * v
    return c1, c2


def _closest_points_on_lines(p1, d1, p2, d2, eps=1e-12):
    """
    两条无限直线 L1: p1 + s*d1, L2: p2 + t*d2 的最近点对
    理想相交时：c1 == c2 == 交点
    """
    p1 = np.asarray(p1, float)
    d1 = np.asarray(d1, float)
    p2 = np.asarray(p2, float)
    d2 = np.asarray(d2, float)

    a = np.dot(d1, d1)
    b = np.dot(d1, d2)
    c = np.dot(d2, d2)
    w0 = p1 - p2
    d = np.dot(d1, w0)
    e = np.dot(d2, w0)

    denom = a * c - b * b
    if abs(denom) < eps:
        s = 0.0
        t = -e / c if c > eps else 0.0
    else:
        s = (b * e - c * d) / denom
        t = (a * e - b * d) / denom

    c1 = p1 + s * d1
    c2 = p2 + t * d2
    return c1, c2


def _unit(v, eps=1e-12):
    v = np.asarray(v, float)
    n = np.linalg.norm(v)
    if n < eps:
        raise ValueError("Zero-length direction vector.")
    return v / n


def _obb_mask(points, origin, ex, ey, ez, half_sizes_xyz):
    """
    points: (M,3)
    origin: (3,)
    ex/ey/ez: (3,) orthonormal basis
    half_sizes_xyz: (3,) -> [hx, hy, hz]
    """
    p = points - origin
    x = p @ ex
    y = p @ ey
    z = p @ ez
    hx, hy, hz = half_sizes_xyz
    return (np.abs(x) <= hx) & (np.abs(y) <= hy) & (np.abs(z) <= hz)


def _dist_to_nearest_endpoint(point, start, end):
    point = np.asarray(point, float)
    start = np.asarray(start, float)
    end = np.asarray(end, float)
    return min(np.linalg.norm(point - start), np.linalg.norm(point - end))


def find_cylinder_connection_indices(
    cyn1, cyn2, pc,
    bbox_half_size,   # 大AABB半边长（粗筛）
    margin=0.0        # 可选余量
):
    """
    返回：
      idx: 原始 pc 的全局索引
      center_big: 用于大AABB的中心（线段最近点中点）
      center_joint: “假设相交”的交点中心（无限直线的交汇点）
    """
    pc = np.asarray(pc, dtype=float)

    p1 = np.asarray(cyn1["start"], dtype=float)
    q1 = np.asarray(cyn1["end"], dtype=float)
    p2 = np.asarray(cyn2["start"], dtype=float)
    q2 = np.asarray(cyn2["end"], dtype=float)

    r1 = float(cyn1["radius"])
    r2 = float(cyn2["radius"])

    # -------- center_big：线段最近点中点（用于大AABB）
    cseg1, cseg2 = _closest_points_on_segments(p1, q1, p2, q2)
    center_big = (cseg1 + cseg2) / 2.0

    # -------- 大AABB粗筛（全局索引）
    bbox_half_size = np.asarray(
        [bbox_half_size] * 3 if np.isscalar(bbox_half_size) else bbox_half_size,
        dtype=float
    )
    min_corner = center_big - bbox_half_size
    max_corner = center_big + bbox_half_size
    inside_big = np.all((pc >= min_corner) & (pc <= max_corner), axis=1)
    idx_big = np.where(inside_big)[0]
    if idx_big.size == 0:
        # 没有点，直接返回
        return idx_big, center_big, None

    pc_big = pc[idx_big]

    # -------- center_joint：假设两轴线可相交，求“交点”
    d1 = q1 - p1
    d2 = q2 - p2
    cl1, cl2 = _closest_points_on_lines(p1, d1, p2, d2)
    center_joint = (cl1 + cl2) / 2.0  # 理想相交时就是交点

    # -------- 建立局部坐标系：x=柱1轴, y=柱2轴, z=cross
    ex = _unit(d1)
    ey = _unit(d2)
    ez = _unit(np.cross(ex, ey))  # 默认垂直，不再判断

    # -------- 两个“交点 OBB”
    # OBB1（柱体1）：x半长 = dist(center_joint,柱1最近端点) + r2；y,z半长= r1
    hx1 = _dist_to_nearest_endpoint(center_joint, p1, q1) + r2 + margin
    hy1 = r1 + margin
    hz1 = r1 + margin
    mask1 = _obb_mask(
        pc_big, origin=center_joint, ex=ex, ey=ey, ez=ez,
        half_sizes_xyz=np.array([hx1, hy1, hz1], dtype=float)
    )

    # OBB2（柱体2）：y半长 = dist(center_joint,柱2最近端点) + r1；x,z半长= r2
    hy2 = _dist_to_nearest_endpoint(center_joint, p2, q2) + r1 + margin
    hx2 = r2 + margin
    hz2 = r2 + margin
    mask2 = _obb_mask(
        pc_big, origin=center_joint, ex=ex, ey=ey, ez=ez,
        half_sizes_xyz=np.array([hx2, hy2, hz2], dtype=float)
    )

    # -------- 细筛并映射回原始 pc 全局索引
    sel_local = np.where(mask1 | mask2)[0]   # pc_big 的局部索引
    idx = idx_big[sel_local]                 # 原始 pc 的全局索引

    return idx, center_big, center_joint


if __name__ == "__main__":
    cyn1 = {"start": [0, 0, 0],   "end": [0, 0, 1],   "radius": 0.05}
    cyn2 = {"start": [0, 0, 0.5], "end": [1, 0, 0.5], "radius": 0.05}

    pc = np.random.rand(10000, 3)

    idx, center_big, center_joint = find_cylinder_connection_indices(
        cyn1, cyn2, pc, bbox_half_size=0.2, margin=0.005
    )

    print("center_big:", center_big)
    print("center_joint:", center_joint)
    print("count:", len(idx))
    print("idx[:10]:", idx[:10])
