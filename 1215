"""
 主函数 gap_points_for_single_broken_cylinder(cyn1, cyn2, pc)
   根据两个相对在同一直线的柱体中间有一段空隙，返回柱体空隙的点云索引。
    """

import numpy as np

def _normalize(v, eps=1e-8):
    v = np.asarray(v, dtype=float)
    n = np.linalg.norm(v)
    if n < eps:
        raise ValueError("Zero-length vector cannot be normalized.")
    return v / n

def gap_points_for_single_broken_cylinder(cyn1, cyn2, pc, margin):
    """
    用于：两个柱体中间有一段空隙。

    参数
    ----
    cyn1, cyn2 : dict
        形如：
        {
            "start": (x, y, z),
            "end": (x, y, z),
            "radius": float
        }
        假设两段柱体轴线是共线/近似共线的。
    pc : (N, 3) array_like
        点云 (x, y, z)
    margin : float
        径向上的“放宽”距离，比如0.01、0.02，
        让空隙区域稍微厚一点，避免太严格。

    返回
    ----
    idx : (M,) np.ndarray[int]
        落在“中间断掉那一段空隙”里的点的索引
    """

    pc = np.asarray(pc, dtype=float)

    s1 = np.asarray(cyn1["start"], dtype=float)
    e1 = np.asarray(cyn1["end"], dtype=float)
    s2 = np.asarray(cyn2["start"], dtype=float)
    e2 = np.asarray(cyn2["end"], dtype=float)

    r1 = float(cyn1["radius"])
    r2 = float(cyn2["radius"])
    r_max = max(r1, r2)

    axis_vec = e1 - s1
    u = _normalize(axis_vec)  # 单位向量，表示柱子的方向

    origin = s1  # 选一个统一的原点来投影（随便，但要固定）

    # 计算两段柱子的轴向范围（在 u 方向上的投影标量）
    def proj(p):
        return np.dot(p - origin, u) # 点 p 在轴向上的标量坐标

    s1_t = proj(s1)
    e1_t = proj(e1)
    s2_t = proj(s2)
    e2_t = proj(e2)

    seg1_min = min(s1_t, e1_t)
    seg1_max = max(s1_t, e1_t)
    seg2_min = min(s2_t, e2_t)
    seg2_max = max(s2_t, e2_t)

    # 找到空隙的轴向区间 [gap_min, gap_max]
    # 情况1: 段1在前，段2在后
    if seg1_max < seg2_min:
        gap_min = seg1_max
        gap_max = seg2_min
    # 情况2: 段2在前，段1在后
    elif seg2_max < seg1_min:
        gap_min = seg2_max
        gap_max = seg1_min
    else:
        return np.zeros((0,), dtype=int) # 两段有重叠或者紧挨着，没有明显“空隙”

    # 如果 gap 太小（几乎没空隙），直接返回空
    if gap_max <= gap_min:
        return np.zeros((0,), dtype=int)

    # 对所有点： 算它在轴向上的标量 t
    vec = pc - origin          # (N, 3)
    t = vec @ u                # (N,)

    axis_comp = np.outer(t, u)  # (N,3) 点在轴线方向的投影
    radial_vec = vec - axis_comp  # 横向偏移量
    radial_dist = np.linalg.norm(radial_vec, axis=1)

    mask = (
            (t >= gap_min) & (t <= gap_max) &
            (radial_dist <= r_max + margin)
    )

    idx = np.nonzero(mask)[0]
    return idx

if __name__ == "__main__":
    np.random.seed(0)

    cyn1 = {
        "start": (0.0, 0.0, 0.0),
        "end": (0.0, 0.0, 4.0),
        "radius": 1.0
    }
    cyn2 = {
        "start": (0.0, 0.0, 6.0),
        "end": (0.0, 0.0, 10.0),
        "radius": 1.0
    }

    # 造一些“空隙中的点”：z 在 (4, 6) 范围，x,y 在圆内
    n_gap = 200
    z_gap = np.random.uniform(4.1, 5.9, size=n_gap)
    theta = np.random.uniform(0, 2 * np.pi, size=n_gap)
    r = np.random.uniform(0, 1.0, size=n_gap)  # 半径以内

    x_gap = r * np.cos(theta)
    y_gap = r * np.sin(theta)
    pc = np.stack([x_gap, y_gap, z_gap], axis=1)

    idx = gap_points_for_single_broken_cylinder(cyn1, cyn2, pc, margin= 0.05)

    print("总点数:", pc.shape[0])
    print("理论上空隙里造了点数:", n_gap)
    print("函数找到的空隙点数:", len(idx))

    gap_pc = pc[idx]
    z_min = gap_pc[:, 2].min() if len(gap_pc) > 0 else None
    z_max = gap_pc[:, 2].max() if len(gap_pc) > 0 else None
    radial = np.linalg.norm(gap_pc[:, :2], axis=1) if len(gap_pc) > 0 else None

    print("选中点的 z 范围:", z_min, " ~ ", z_max)
    if radial is not None:
        print("选中点的径向距离: min =", radial.min(), ", max =", radial.max())
