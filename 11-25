import random
import matplotlib.pyplot as plt
from scipy.spatial import KDTree
from numpy.linalg import svd
from sklearn.neighbors import NearestNeighbors
import numpy as np
from typing import List, Tuple, Optional
# last_cluster_labels = None

def centralize_data(data, central=True):
    """
    将点云数据中心化（减去均值）并记录偏移量
    参数:
        data: 点云数据，形状为 (N, 3+) 的 NumPy 数组，前3列必须是 [x, y, z]
        central: 是否执行中心化
    返回:
        data_centralized: 中心化后的数据（如果 central=False 则返回原数据）
        offset: 三个方向的偏移量 [x_offset, y_offset, z_offset]
    """
    if not central:
        return data, np.zeros(3)  # 不中心化时返回原数据和零偏移

    # 提取前3列坐标（x, y, z）
    xyz = data[:, :3]

    # 计算各方向的均值（偏移量）
    offset = np.mean(xyz, axis=0)

    # 中心化：减去偏移量
    data_centralized = data.copy()
    data_centralized[:, :3] = xyz - offset

    return data_centralized, offset
def load_txt_data(file_path,downsample_factor=10,random_seed=1,central=False):
    '''x,y,z,nx,ny,nz,dir,radius,semantic_label'''
    data = np.loadtxt(file_path)
    sampled_indices = np.arange(len(data))
   
    # 中心化
    offset = np.zeros(3)
    if central:
        data, offset = centralize_data(data, central=True)
    # instance_id = data[:,11]
    points = data[:, :3]  # surface points
    cls = data[:, 10][:]
    normals = data[:, 3:6]  # surface normal, from surface to centerline
    radii = data[:, 9]
    # 这里是孟传的合成数据
    # pipe_mask = np.isin(cls, [17, 35])
    pipe_mask = cls==1
    surface_points = points[pipe_mask]  # keep original surface points
    surface_normals = normals[pipe_mask]
    pipe_radii = radii[pipe_mask]
    # instance_id = instance_id[pipe_mask]
    centerline_points = surface_points - pipe_radii[:, None] * surface_normals
    pipe_dirs = data[pipe_mask,6:9]  # fixed pipe direction
    # all_points = data[:, :3]
    return centerline_points, pipe_radii, surface_points, pipe_dirs, offset, sampled_indices,surface_normals
def load_pts_data(file_path):
    #points:x,y,z,r,nx,ny,nz,
    data = np.loadtxt(file_path)
    points = data[:, :3]  # surface points
    cls = data[:, 10:13]
    normals = data[:, 4:7]
    normalss = np.linalg.norm(normals,axis=1,keepdims=True)+1e-8# surface normal, from surface to centerline
    normals = normals/normalss
    radii = data[:, 3]
    pipe_mask = cls[:,1]==cls[:,2]
    print(pipe_mask.sum())
    surface_points = points[pipe_mask]  # keep original surface points
    surface_normals = normals[pipe_mask]
    pipe_radii = radii[pipe_mask]
    # 法线朝外
    centerline_points = surface_points - pipe_radii[:, None] * surface_normals
    # 方向假设
    pipe_dirs = np.tile(np.array([[0, 1, 0]]), (len(centerline_points), 1))  # fixed pipe direction
    all_points = data[:, :3]
    return centerline_points, pipe_radii, surface_points, pipe_dirs
def load_np_data(file_path):

    data = np.load(file_path).astype(np.float32)
    points = data[:, :3]  # surface points
    cls = data[:, 3]
    normals = data[:, 5:8]  # surface normal, from surface to centerline
    radii = data[:, 4]
    pipe_mask = cls >0
    #np.set_printoptions(threshold=np.inf)
    print(pipe_mask.sum())
    surface_points = points[pipe_mask]  # keep original surface points
    surface_normals = normals[pipe_mask]
    pipe_radii = radii[pipe_mask]
    centerline_points = surface_points - pipe_radii[:, None] * surface_normals
    pipe_dirs = np.tile(np.array([[0, 1, 0]]), (len(centerline_points), 1))  # fixed pipe direction
    all_points = data[:, :3]
    return centerline_points, pipe_radii, surface_points, pipe_dirs
def instance_cluster(instance_id):
    # Get unique instance IDs
    unique_ids = np.unique(instance_id)

    # Create a dictionary to map instance_id to label
    id_to_label = {id_: idx for idx, id_ in enumerate(unique_ids)}

    # Convert instance_id array to labels
    labels = np.array([id_to_label[id_] for id_ in instance_id], dtype=np.int32)

    return labels

def region_growing_with_direction(points, directions, radius=0.2, angle_threshold=np.deg2rad(30), min_points=10):
    nbrs = NearestNeighbors(radius=radius).fit(points)
    all_neighbors = nbrs.radius_neighbors(points, return_distance=False)
    visited = np.zeros(len(points), dtype=bool)
    labels = -1 * np.ones(len(points), dtype=int)
    current_label = 0
    norm_directions = directions / (np.linalg.norm(directions, axis=1, keepdims=True) + 1e-6)
    cos_threshold = np.cos(angle_threshold)

    for i in range(len(points)):
        if visited[i]:
            continue
        queue = [i]
        visited[i] = True
        segment = []

        while queue:
            idx = queue.pop()
            segment.append(idx)
            # neighbors = nbrs.radius_neighbors([points[idx]], return_distance=False)[0]
            neighbors = all_neighbors[idx]
            for n_idx in neighbors:
                if visited[n_idx]:
                    continue
                # ang = angle_between(directions[idx], directions[n_idx])
                # if ang < angle_threshold:
                if np.dot(norm_directions[idx], norm_directions[n_idx]) > cos_threshold:
                    visited[n_idx] = True
                    queue.append(n_idx)

        if len(segment) >= min_points:
            for idx in segment:
                labels[idx] = current_label
            current_label += 1
# 15 only
#     print(len(np.unique(labels)))
    return labels


def region_growing_with_direction_optimized(points, directions, radius=0.2, angle_threshold=np.deg2rad(30),
                                            min_points=10, down_sample_factor=10):
  
    # Step 1: 对点云进行随机下采样
    N = len(points)
    if N < min_points:
        return -1 * np.ones(N, dtype=int)
    idx = np.random.choice(N, N // down_sample_factor, replace=False)
    downsampled_points = points[idx]
    downsampled_directions = directions[idx]

    # Step 2: 在下采样的点云上应用原始聚类算法
    downsampled_labels = region_growing_with_direction(
        downsampled_points, downsampled_directions,
        radius, angle_threshold, min_points
    )
    unique_labels = np.unique(downsampled_labels)
    unique_labels = unique_labels[unique_labels >= 0]  # 移除噪声点标签(-1)

    # Step 3: 用所有下采样聚类点（不仅是中心）作为种子点
    tree_full = KDTree(points)
    labels_full = -1 * np.ones(N, dtype=int)

    for label in unique_labels:
        # 获取当前聚类内的所有下采样点
        seed_mask = (downsampled_labels == label)
        cluster_seeds = downsampled_points[seed_mask]

        # 对每个种子点，标记其原始点云中的邻域点
        for seed in cluster_seeds:
            neighbor_indices = tree_full.query_ball_point(seed, r=radius)

            # 只标记未被分配或距离更近的点（避免重复覆盖）
            for idx in neighbor_indices:
                # if labels_full[idx] == -1:  # 未分配标签的点直接标记
                labels_full[idx] = label

    return labels_full


# zhh: 差别是，用一个子集来作为搜索邻域的种子点
def region_growing_with_direction2(points, directions, idx_seeds, radius=0.2, angle_threshold=np.deg2rad(30),
                                   min_points=10):
    nbrs = NearestNeighbors(radius=radius).fit(points)
    points_seeds = points[idx_seeds]
    labels = -1 * np.ones(len(points), dtype=int)
    if points_seeds.shape[0]==0:
        return labels
    all_neighbors = nbrs.radius_neighbors(points_seeds, return_distance=False)

    # 全集中向seed集的指针，-1表示不在seed中
    idx_full2seed = [-1, ] * len(points)
    for id_seed in range(len(idx_seeds)): idx_full2seed[idx_seeds[id_seed]] = id_seed

    visited = np.zeros(len(points), dtype=bool)
    
    current_label = 0
    norm_directions = directions / (np.linalg.norm(directions, axis=1, keepdims=True) + 1e-6)
    cos_threshold = np.cos(angle_threshold)

    for id_seed in range(len(idx_seeds)):
        i = idx_seeds[id_seed]  # i转成全集的idx.
        assert idx_full2seed[i] == id_seed, 'wrong. data not consistent.'
        if visited[i]: continue
        queue = [i]  # 这里保存的是seed点，不过值表示fullset中的index.
        visited[i] = True
        segment = [i, ]  # 这里是full点集中的点

        while queue:
            idx = queue.pop()
            # segment.append(idx)
            # neighbors = nbrs.radius_neighbors([points[idx]], return_distance=False)[0]
            neighbors = all_neighbors[idx_full2seed[idx]]
            for n_idx in neighbors:
                if visited[n_idx]:
                    continue
                # ang = angle_between(directions[idx], directions[n_idx])
                # if ang < angle_threshold:
                if np.dot(norm_directions[idx], norm_directions[n_idx])> cos_threshold: # modify yw
                    visited[n_idx] = True
                    segment.append(n_idx)
                    if idx_full2seed[n_idx] >= 0: queue.append(n_idx)

        if len(segment) >= min_points:
            for idx in segment:
                labels[idx] = current_label
            current_label += 1
    # 15 only
    #     print(len(np.unique(labels)))
    return labels


# 张辉 updated: 打算实现相同的功能.
def region_growing_with_direction_optimized2(points, directions, radius=0.2, angle_threshold=np.deg2rad(30),
                                             min_points=10, down_sample_factor=10):
  
    # Step 1: 对点云进行随机下采样
    N = len(points)
    if N < min_points:
        return -1 * np.ones(N, dtype=int)
    idx = np.random.choice(N, N // down_sample_factor, replace=False)
    # downsampled_points = points[idx]
    # downsampled_directions = directions[idx]

    # Step 2: 在下采样的点云上应用原始聚类算法
    labels_full = region_growing_with_direction2(points, directions, idx, radius, angle_threshold, min_points)
    return labels_full

def hierarchical_region_growing(points, directions, initial_labels=None,radius=0.02, angle_threshold=np.deg2rad(30), min_points=30):
    
    if initial_labels is None:
        # 如果没有初始标签，直接调用原函数
        # return region_growing_with_direction(points, directions, radius, angle_threshold, min_points)
        return region_growing_with_direction_optimized2(points, directions, radius, angle_threshold, min_points)
    final_labels = -1 * np.ones_like(initial_labels)
    label_offset = 0

    # 对每个初始组单独处理
    for group_id in np.unique(initial_labels):
        group_mask = (initial_labels == group_id)
        group_points = points[group_mask]
        group_directions = directions[group_mask]

        
        group_labels = region_growing_with_direction_optimized2(group_points, group_directions, radius, angle_threshold, min_points)
        # 将当前组的有效标签（非-1）映射到全局标签空间
        valid_mask = (group_labels != -1)
        final_labels[group_mask] = np.where(
            valid_mask,
            group_labels + label_offset,
            -1
        )

        # 更新标签偏移量（取当前组最大标签+1）
        if np.any(valid_mask):
            label_offset += np.max(group_labels[valid_mask]) + 1

    return final_labels
def radius_cluster(points, radius, dir, atol=0.001, enable_dir_clustering=True, angle_threshold=5.0):
    
    labels = np.full(len(points), -1, dtype=int)
    current_label = 0

    # 1. 按半径分组
    unique_radii = np.unique(np.round(radius, decimals=6))

    for r in unique_radii:
        mask = np.isclose(radius, r, atol=atol)
        group_indices = np.where(mask)[0]  # 当前半径组的原始索引

        if len(group_indices) == 0:
            continue

        # 2. 如果启用方向分类，则进一步分组
        if enable_dir_clustering:
            group_dirs = dir[group_indices]

            # 定义基准方向：x/y/z轴
            ref_directions = np.array([
                [1, 0, 0],  # x轴
                [0, 1, 0],  # y轴
                [0, 0, 1]  # z轴
            ])

            # 计算每个点与三个基准方向的余弦相似度
            cosine_sim = np.abs(np.dot(group_dirs, ref_directions.T))  # (M, 3)
            # cosine_sim = np.dot(group_dirs, ref_directions.T)  # (M, 3)

            max_cosine = np.max(cosine_sim, axis=1)
            best_match = np.argmax(cosine_sim, axis=1)  # 每个点最接近的基准方向索引

            # 检查是否超过角度阈值（余弦值 >= cos(angle_threshold)）
            cos_threshold = np.cos(np.deg2rad(angle_threshold))
            valid_mask = (max_cosine >= cos_threshold)

            # 分配标签：有效点按基准方向分组，无效点单独分组
            for ref_idx in range(3):
                dir_mask = (best_match == ref_idx) & valid_mask
                if np.any(dir_mask):
                    labels[group_indices[dir_mask]] = current_label
                    current_label += 1

            # 处理无效点（方向不匹配任何基准）
            # invalid_mask = ~valid_mask
            # if np.any(invalid_mask):
            #     labels[group_indices[invalid_mask]] = current_label
            #     current_label += 1        
        else:
            # 不启用方向分类，直接分配同一标签
            labels[group_indices] = current_label
            current_label += 1

    return labels

def dir_est(sur_normals, lbl):
    # 获取所有唯一的标签
    unique_labels = np.unique(lbl)
    # 初始化结果数组，形状与 sur_normals 相同
    a_est = np.zeros_like(sur_normals)

    for i in unique_labels:
        # 获取当前标签对应的法向量
        if i==-1:
            continue
        mask = (lbl == i)
        sur_normal = sur_normals[mask]

        # 检查是否有足够的样本（至少 3 个点）
        if sur_normal.shape[0] >= 3:
            # 计算 SVD
            _, _, Vt = svd(sur_normal, full_matrices=False)
            # 最小奇异值对应的向量（Vt 的最后一行）
            min_singular_vector = Vt[-1]
            # 将结果填充到对应位置
            a_est[mask] = min_singular_vector
        else:
            # 如果样本不足，填充零向量或跳过
            a_est[mask] = np.zeros(3)
    return a_est

def ransac_line_fitting_with_direction(points, directions, max_iterations=100, distance_threshold=0.02,
                                        min_inliers_ratio=0.4, angle_threshold=np.deg2rad(15)):
    # distance_threshold important
    best_inlier_count = 0
    best_model = None
    n_points = len(points)
    min_inliers = int(n_points * min_inliers_ratio)

    def angle_between(v1, v2):
        v1 = v1 / (np.linalg.norm(v1) + 1e-6)
        v2 = v2 / (np.linalg.norm(v2) + 1e-6)
        return np.arccos(np.clip(np.dot(v1, v2), -1.0, 1.0))

    for _ in range(max_iterations):
        idx = np.random.choice(n_points, 2, replace=False)
        p1, p2 = points[idx]
        direction = p2 - p1
        if np.linalg.norm(direction) < 1e-6:
            continue
        direction = direction / np.linalg.norm(direction)

        vecs = points - p1
        projections = np.dot(vecs, direction)[:, np.newaxis] * direction
        dists = np.linalg.norm(vecs - projections, axis=1)
        inlier_mask = dists < distance_threshold

        if np.sum(inlier_mask) < min_inliers:
            continue

        avg_angle = np.mean([angle_between(direction, d) for d in directions[inlier_mask]])
        if avg_angle > angle_threshold:
            continue

        inlier_count = np.sum(inlier_mask)
        if inlier_count > best_inlier_count:
            best_inlier_count = inlier_count
            best_model = (direction, p1.copy(), inlier_mask)

    if best_model is not None:
        return best_model
    else:
        return None, None, np.ones(n_points, dtype=bool)
def ransac_lines_fitting_with_direction(remaining_points, remaining_dirs, threshold=0.005,
                                       max_iterations=1000, min_inliers=100):

    if len(remaining_points) < min_inliers:
        return None, None, None

    n = remaining_points.shape[0]
    best_inlier_count = 0
    best_direction = None
    best_point_on_line = None
    best_inlier_mask = None

    for _ in range(max_iterations):
        # 随机选择一个点作为直线上的点
        idx = np.random.randint(n)
        point_on_line = remaining_points[idx]
        direction = remaining_dirs[idx]

        # 归一化方向向量
        norm = np.linalg.norm(direction)
        if norm < 1e-10:  # 避免零向量
            continue
        norm_direction = direction / norm

        # 计算所有点到直线的距离
        vectors = remaining_points - point_on_line
        cross_products = np.cross(vectors, norm_direction)
        distances = np.linalg.norm(cross_products, axis=1)

        # 确定内点
        inlier_mask = distances < threshold
        inlier_count = np.sum(inlier_mask)
        if inlier_count < min_inliers:
            continue
        # 提前终止：如果当前内点已经远超过历史最佳
        if inlier_count > best_inlier_count and inlier_count >= min_inliers:
            best_inlier_count = inlier_count
            best_direction = norm_direction
            best_point_on_line = point_on_line
            best_inlier_mask = inlier_mask

            # 提前终止条件：如果找到足够多的内点
            if inlier_count > 0.9 * n:  # 90%的点都是内点
                break

    # 检查最终内点数量是否满足要求
    if best_inlier_count < min_inliers:
        return None, None, None

    # 使用所有内点重新拟合直线
    inlier_points = remaining_points[best_inlier_mask]
    best_point_on_line = np.mean(inlier_points, axis=0)  # 使用内点的均值作为直线上的点

    # 方向取内点方向的平均值并归一化
    inlier_dirs = remaining_dirs[best_inlier_mask]
    best_direction = np.mean(inlier_dirs, axis=0)
    norm = np.linalg.norm(best_direction)
    if norm < 1e-10:  # 处理零向量情况
        best_direction = np.array([1.0, 0.0, 0.0])  # 默认方向
    else:
        best_direction = best_direction / norm

    return best_direction, best_point_on_line, best_inlier_mask
def fit_cylinder_with_custom_ransac(points, input_radii, directions):
    if len(points) < 3:
        # fallback for extremely small clusters
        center = np.mean(points, axis=0)
        direction = np.mean(directions, axis=0)
        direction = direction / (np.linalg.norm(direction) + 1e-6)
        start = center - 0.5 * np.mean(input_radii) * direction
        end = center + 0.5 * np.mean(input_radii) * direction
        radius = np.mean(input_radii)
        return start, end, direction, radius

    direction, point_on_line, inlier_mask = ransac_line_fitting_with_direction(points, directions)
    if direction is None or np.linalg.norm(np.ptp(points, axis=0)) < 0.5*np.mean(input_radii):
        # fallback to direction-aware fitting using average direction
        print("WAY TOO SHORT!!!!")
        center = np.mean(points, axis=0)
        direction = np.mean(directions, axis=0)
        #direction = direction / (np.linalg.norm(direction) + 1e-6)
        projections = np.dot(points - center, direction)
        t_min, t_max = np.min(projections), np.max(projections)
        start = center + t_min * direction
        end = center + t_max * direction
    else:
        inlier_points = points[inlier_mask]
        projections = np.dot(inlier_points - point_on_line, direction)
        t_min, t_max = np.min(projections), np.max(projections)
        start = point_on_line + t_min * direction
        end = point_on_line + t_max * direction

    radius = np.mean(input_radii[inlier_mask]) if direction is not None else np.mean(input_radii)
    return start, end, direction, radius
def fit_cylinders_with_custom_ransac(points,input_radii,directions,min_points_per_pipe=30,max_pipes=5):
    remaining_points = points.copy()
    remaining_radii = input_radii.copy()
    remaining_dirs = directions.copy()
    pipes = []

    for _ in range(max_pipes):
        if len(remaining_points) < min_points_per_pipe:
            break

        # 拟合当前管道
        direction, point_on_line, inlier_mask = ransac_lines_fitting_with_direction(
            remaining_points, remaining_dirs,min_inliers=int(0.2*len(remaining_points))
        )
        if direction is None:
            break

        inlier_points = remaining_points[inlier_mask]
        inlier_radii = remaining_radii[inlier_mask]
        inlier_dirs = remaining_dirs[inlier_mask]

        # 计算中心线端点
        projections = np.dot(inlier_points - point_on_line, direction)
        t_min, t_max = np.min(projections), np.max(projections)
        start = point_on_line + t_min * direction
        end = point_on_line + t_max * direction
        radius = np.mean(inlier_radii)

        # # 检查方向一致性（过滤噪声）
        # dir_errors = np.arccos(np.clip(np.abs(np.dot(inlier_dirs, direction)), 0, 1))
        # if np.mean(dir_errors) > angle_threshold:
        #     continue  # 跳过方向不一致的管道

        # # 检查半径一致性（避免合并不同管道）
        # if np.ptp(inlier_radii) > radius_diff_threshold:
        #     continue  # 跳过半径差异过大的区域

        # 保存当前管道
        pipes.append((start, end, direction, radius,inlier_points, inlier_radii,inlier_dirs))

        # 移除已拟合的点
        remaining_points = remaining_points[~inlier_mask]
        remaining_radii = remaining_radii[~inlier_mask]
        remaining_dirs = remaining_dirs[~inlier_mask]

    return pipes
# ransac 检测多条直线fit_line_ransac和detect_multiple_pipes,fit_line_ransac_dir
def fit_line_ransac_dir_radius(points, dir_vec, min_samples,radius,ratio=0.2, max_trials=1000,seed=1):
    """
    使用已知方向向量的RANSAC直线拟合
    random.seed(1)
    best_inliers = []
    best_start = None
    best_end = None
    n_points = len(points)
    # 确保方向向量是单位向量
    dir_vec = dir_vec / np.linalg.norm(dir_vec)
    cross_matrix = np.array([
        [0, -dir_vec[2], dir_vec[1]],
        [dir_vec[2], 0, -dir_vec[0]],
        [-dir_vec[1], dir_vec[0], 0]
    ])
    for _ in range(max_trials):
        # 1. 随机采样1个点（不再需要采样2个点）
        idx_sample = random.randint(0, n_points - 1)
        pt = points[idx_sample]
        radii = radius[idx_sample]
   
        mask = distances <= ratio
        inliers = mask.nonzero()[0]  # 更高效

        # 5. 更新最佳模型
        if len(inliers) > len(best_inliers):
            best_inliers = inliers
            # 起点和终点取内点的最小/最大投影点,pt是否需要取mean，或者pt不断迭代
            pt = np.mean(points[best_inliers],axis=0)
            projections = np.dot(points[inliers] - pt, dir_vec)
            best_start = pt + np.min(projections) * dir_vec
            best_end = pt + np.max(projections) * dir_vec
    if len(best_inliers) <= min_samples:
        return None  # 未找到有效直线
    return best_start, best_end, dir_vec, best_inliers
def fit_line_ransac_dir(points, dir_vec, residual_threshold=0.2, max_trials=1000):
    """
    使用已知方向向量的RANSAC直线拟合
    参数:
        points: 点云数据 (N x 3)
        dir_vec: 已知的单位方向向量 [dx, dy, dz]
        residual_threshold: 内点距离阈值（点到直线的最大允许距离）
        max_trials: 最大迭代次数
    返回:
        start: 直线起点 [x, y, z]
        end: 直线终点 [x, y, z]
        direction: 单位方向向量 [dx, dy, dz]（与输入的dir_vec相同）
        inliers: 内点索引列表
    """
    best_inliers = []
    best_start = None
    best_end = None
    n_points = len(points)
    # 确保方向向量是单位向量
    dir_vec = dir_vec / np.linalg.norm(dir_vec)
    for _ in range(max_trials):
        # 1. 随机采样1个点（不再需要采样2个点）
        idx_sample = random.randint(0, n_points - 1)
        pt = points[idx_sample]
        # 2. 直接使用已知方向向量dir_vec，无需计算方向
        # 3. 计算所有点到直线的距离
        # 方法：距离 = ||(p - pt) × dir_vec||（dir_vec已经是单位向量）
        vec_to_pt = points - pt
        cross_product = np.cross(vec_to_pt, dir_vec)
        distances = np.linalg.norm(cross_product, axis=1)
        # 4. 筛选内点
        inliers = np.where(distances <= residual_threshold)[0]
        # 5. 更新最佳模型
        if len(inliers) > len(best_inliers):
            best_inliers = inliers
            # 起点和终点取内点的最小/最大投影点
            projections = np.dot(points[inliers] - pt, dir_vec)
            best_start = pt + np.min(projections) * dir_vec
            best_end = pt + np.max(projections) * dir_vec
    if len(best_inliers) == 0:
        return None  # 未找到有效直线
    return best_start, best_end, dir_vec, best_inliers
def fit_line_ransac(points, residual_threshold=0.2, max_trials=1000):
    """
    纯NumPy实现的RANSAC直线拟合
    参数:
        points: 点云数据 (N x 3)
        residual_threshold: 内点距离阈值（点到直线的最大允许距离）
        max_trials: 最大迭代次数
    返回:
        start: 直线起点 [x, y, z]
        end: 直线终点 [x, y, z]
        direction: 单位方向向量 [dx, dy, dz]
        inliers: 内点索引列表
    """
    best_inliers = []
    best_start = None
    best_end = None
    best_direction = None
    n_points = len(points)

    for _ in range(max_trials):
        # 1. 随机采样2个点
        idx_samples = random.sample(range(n_points), 2)
        pt1, pt2 = points[idx_samples]

        # 2. 计算直线方向向量
        direction = pt2 - pt1
        norm = np.linalg.norm(direction)

        # 避免两点重合导致方向为0
        if norm < 1e-6:
            continue

        direction = direction / norm  # 单位化

        # 3. 计算所有点到直线的距离
        # 方法：距离 = ||(p - pt1) × direction|| / ||direction|| (因direction是单位向量，分母为1)
        vec_to_pt1 = points - pt1
        cross_product = np.cross(vec_to_pt1, direction)
        distances = np.linalg.norm(cross_product, axis=1)

        # 4. 筛选内点
        inliers = np.where(distances <= residual_threshold)[0]

        # 5. 更新最佳模型
        if len(inliers) > len(best_inliers):
            best_inliers = inliers
            best_direction = direction
            # 起点和终点取内点的最小/最大投影点
            projections = np.dot(points[inliers] - pt1, direction)
            start = pt1 + np.min(projections) * direction
            end = pt1 + np.max(projections) * direction

    if len(best_inliers) == 0:
        return None  # 未找到有效直线

    return start, end, best_direction, best_inliers
def detect_multiple_pipes(
        points: np.ndarray,
        directions: Optional[np.ndarray] = None,
        radii: Optional[np.ndarray] = None,
        surf: Optional[np.ndarray] = None,
        max_pipes: int = 10,
        min_samples_ratio: float=0.2,
        min_samples=30,
        residual_threshold: float = 0.2,
        max_trials: int = 1000
) -> List[Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray, Optional[np.ndarray], Optional[np.ndarray],Optional[np.ndarray]]]:
   
    min_samples = min(min_samples,min_samples_ratio * len(points))
    # 初始化全局索引
    global_indices = np.arange(len(points))
    remaining_indices = global_indices.copy()
    remaining_points = points.copy()
    remaining_dirs = directions.copy() if directions is not None else None
    remaining_radii = radii.copy() if radii is not None else None
    remaining_surf = surf.copy() if surf is not None else None

    pipes = []

    for _ in range(max_pipes):
        if len(remaining_points) < min_samples:
            break

        dir_vec = np.mean(remaining_dirs, axis=0)
        # dir_vec = remaining_dirs[max_dir_id]
        result = fit_line_ransac_dir_radius(remaining_points, dir_vec=dir_vec,min_samples=min_samples,radius=remaining_radii,
                                     ratio=residual_threshold,
                                     max_trials=max_trials,seed=1)# modify yw: dir_vec=np.mean(remaining_dirs, axis=0),
        if result is None:
            break

        start, end, direction, inliers = result

        # 获取全局索引（关键修正点）
        global_inliers = remaining_indices[inliers]
        inlier_points = points[global_inliers]  # 直接映射到原始点云
        inlier_dirs = directions[global_inliers] if directions is not None else None
        inlier_radii = radii[global_inliers] if radii is not None else None
        inlier_surf = surf[global_inliers] if surf is not None else None
        radius = np.mean(inlier_radii)

        # 20250926, mcwei, return more infos for visualization.
        ind_inlier = global_inliers
        pipes.append((
            start, end, direction,radius,
            inlier_points, inlier_radii, inlier_dirs,inlier_surf,
            ind_inlier,  # the indices of inlier points.
        ))

        # 更新剩余点集（通过布尔掩码）
        mask = np.ones(len(remaining_points), dtype=bool)
        mask[inliers] = False
        remaining_points = remaining_points[mask]
        remaining_indices = remaining_indices[mask]
        if remaining_dirs is not None:
            remaining_dirs = remaining_dirs[mask]
        if remaining_radii is not None:
            remaining_radii = remaining_radii[mask]
        if remaining_surf is not None:
            remaining_surf = remaining_surf[mask]

    return pipes
class PipeSegment:
    '''得到中心线start，end，r'''
    def __init__(self, segment_points, segment_radii, segment_dirs,segment_surf=None):
        self.raw_points = segment_points
        self.input_radii = segment_radii
        self.directions = segment_dirs
        self.surf = segment_surf
        self.centerline_start = None
        self.centerline_end = None
        self.direction = None
        self.radius = None
        # self.fit_cylinder()
        self.fit_cylinder_optimized()

    def fit_cylinder(self):
        start, end, direction, radius = fit_cylinder_with_custom_ransac(
            self.raw_points, self.input_radii, self.directions)
        self.centerline_start = start
        self.centerline_end = end
        self.direction = direction
        self.radius = radius
    def fit_cylinder_optimized(self):
        pipes_data = detect_multiple_pipes(
            self.raw_points, self.directions, self.input_radii, self.surf,
            max_pipes=1,
            min_samples_ratio=0.1,
            min_samples=30,
            residual_threshold=0.05
        )
        if len(pipes_data) == 0:
            return None
        pipes_data=pipes_data[0]
        # 将每条管道转换为PipesSegment对象
        # start, end, direction, radius = fit_cylinder_with_custom_ransac(
        #     self.raw_points, self.input_radii, self.directions)
        self.centerline_start = pipes_data[0]
        self.centerline_end = pipes_data[1]
        self.direction = pipes_data[2]
        self.radius = pipes_data[3]
class PipesSegment:
    """单根管道的几何属性（中心线起点、终点、方向、半径）"""
    # 20250926, mcwei, return more infos for visualization.
    def __init__(self, centerline_start, centerline_end, direction, radius, inlier_points,inlier_radii,inlier_dirs,inlier_surf, ind_inlier, lst_id_cluster):
        self.centerline_start = centerline_start  # 起点坐标 [x,y,z]
        self.centerline_end = centerline_end      # 终点坐标 [x,y,z]
        self.direction = direction                # 方向向量 [dx,dy,dz]
        self.radius = radius                      # 管道半径
        self.raw_points = inlier_points              # 可选：关联的原始点云数据
        self.input_radii = inlier_radii
        self.directions = inlier_dirs
        self.surf = inlier_surf

        # 20250926, mcwei, return more infos for visualization.
        self.ind_inlier = ind_inlier  # the indices of inlier points.
        self.ind_clustered = None  # the indices of clustered points.
        self.lst_id_cluster = lst_id_cluster  # ids of the related cluster.

    @property
    def length(self):
        """计算管道长度"""
        return np.linalg.norm(self.centerline_end - self.centerline_start)
class PipeSegments:
    """一个点云分段中检测到的所有管道"""
    def __init__(self, segment_points, segment_radii, segment_dirs,segment_surf):
        self.raw_points = segment_points  # 原始点云坐标
        self.input_radii = segment_radii  # 点云半径
        self.directions = segment_dirs    # 点云方向
        self.surf = segment_surf
        self.pipes = []                   # 存储多个PipesSegment实例
        self._fit_cylinders()

    def _fit_cylinders(self):
        pipes_data = detect_multiple_pipes(
            self.raw_points, self.directions, self.input_radii,self.surf,
            max_pipes=1,#5
            min_samples_ratio=0.2, # 0.2
            min_samples=0,# 1500
            residual_threshold=0.05
        )
        # 将每条管道转换为PipesSegment对象
        # 20250926, mcwei, return more infos for visualization.
        self.pipes = [
            PipesSegment(
                centerline_start=start,
                centerline_end=end,
                direction=dir,
                radius=radius,
                inlier_points=inlier_points,  # 可选传递原始点云
                inlier_radii=inlier_radii,
                inlier_dirs = inlier_dirs,
                inlier_surf = inlier_surf,
                ind_inlier=ind_inlier,  # the indices of inlier points.
                lst_id_cluster=[i],  # ids of the related cluster.
            ) for i, (start, end, dir, radius,inlier_points,inlier_radii,inlier_dirs,inlier_surf, ind_inlier) in enumerate(pipes_data)
        ]
    def __iter__(self):
        """支持迭代遍历管道"""
        return iter(self.pipes)

    def __len__(self):
        """返回管道数量"""
        return len(self.pipes)

    def filter_by_radius(self, min_radius):
        """过滤半径过小的管道"""
        self.pipes = [p for p in self.pipes if p.radius >= min_radius]
def extract_segments(points, radii, dirs, labels,surf=None):
    segments = []
    labels_seg = []
    for label in np.unique(labels):
        if label == -1:
            continue
        if label == 162:
            print(label)
        mask = labels == label
        seg_points = points[mask]
        seg_radii = radii[mask]
        seg_dirs = dirs[mask]
        seg_surf = surf[mask]
        # if len(seg_points) < 5:
        #     continue


        # segment = PipeSegment(seg_points, seg_radii, seg_dirs)
        # segments.append(segment)
        segment = PipeSegments(seg_points, seg_radii, seg_dirs,seg_surf).pipes
        for i in segment:
            if i == None:
                continue

            # 20250926, mcwei, return more infos for visualization.
            i.ind_clustered = mask.nonzero()[0]
            i.ind_inlier = i.ind_clustered[i.ind_inlier]

            segments.append(i)
            labels_seg.append(label)
    return segments,labels_seg

def _dist(a, b) -> float:
    """Shortest distance between two finite line segments (a and b).

    Uses the algorithm for the closest distance between two segments in 3‑D.
    Returns **one scalar distance** in metres.
    """
    p, q = a.centerline_start, b.centerline_start
    u, v = a.centerline_end - a.centerline_start, b.centerline_end - b.centerline_start
    w0 = p - q

    a_len = np.dot(u, u)
    b_len = np.dot(v, v)
    ab = np.dot(u, v)
    aw = np.dot(u, w0)
    bw = np.dot(v, w0)

    denom = a_len * b_len - ab * ab + 1e-12  # avoid div‑by‑zero

    s = (ab * bw - b_len * aw) / denom
    t = (a_len * bw - ab * aw) / denom

    s = np.clip(s, 0.0, 1.0)
    t = np.clip(t, 0.0, 1.0)

    closest_a = p + s * u
    closest_b = q + t * v
    return float(np.linalg.norm(closest_a - closest_b))
def refine_centerline_segments_with_direction(segments, angle_threshold=np.deg2rad(10), distance_threshold=0.2,radius_threshold=0.2,line_distance_threshold=0.05):
    # distance_threshold重要
    refined = []
    used = set()

    def angle_between(v1, v2):
        v1 = v1 / (np.linalg.norm(v1) + 1e-6)
        v2 = v2 / (np.linalg.norm(v2) + 1e-6)
        return np.arccos(np.clip(np.dot(v1, v2), -1.0, 1.0)) # modify yw: direction

    def radius_between(r1, r2):
        return abs(r1 - r2) <= radius_threshold

    def line_to_line_distance(seg1, seg2):
        p1 = seg1.centerline_start  # 直线1上的点
        d1 = seg1.direction  # 直线1的方向向量
        p2 = seg2.centerline_start  # 直线2上的点
        d2 = seg2.direction  # 直线2的方向向量

        cross = np.cross(d1, d2)
        if np.linalg.norm(cross) < 1e-6:  # 平行直线
            # 计算点到直线的距离
            return np.linalg.norm(np.cross(d1, p2 - p1)) / np.linalg.norm(d1)
        else:  # 不平行直线
            return np.abs(np.dot(p2 - p1, cross)) / np.linalg.norm(cross)
    for i, seg_i in enumerate(segments):
        if i in used:
            continue
        merged_indices = [i]
        for j, seg_j in enumerate(segments):
            if j <= i or j in used:
                continue
            if angle_between(seg_i.direction, seg_j.direction) > angle_threshold:
                continue
            if not radius_between(seg_i.radius, seg_j.radius):
                continue
            # 条件3：直线距离 ≤ line_distance_threshold（新增严格约束）
            if line_to_line_distance(seg_i, seg_j) > line_distance_threshold:
            # if line_to_line_distance(seg_i, seg_j) > 1.2*max(abs(seg_i.radius), abs(seg_j.radius)):
                continue
            ed = _dist(seg_i, seg_j)
            # endpoints_i = [seg_i.centerline_start, seg_i.centerline_end]
            # endpoints_j = [seg_j.centerline_start, seg_j.centerline_end]
            # ed = min(np.linalg.norm(p1 - p2) for p1 in endpoints_i for p2 in endpoints_j)
            if ed < distance_threshold:
                merged_indices.append(j)
        if len(merged_indices) == 1:
            refined.append(seg_i)
        else:
            merged_points = np.concatenate([segments[k].raw_points for k in merged_indices], axis=0)
            merged_radii = np.concatenate([segments[k].input_radii for k in merged_indices], axis=0)
            merged_dirs = np.concatenate([segments[k].directions for k in merged_indices], axis=0)
            merged_surf = np.concatenate([segments[k].surf for k in merged_indices], axis=0)
            merged_segment = PipeSegment(merged_points, merged_radii, merged_dirs,merged_surf)
            # merged_segment = PipeSegments(merged_points, merged_radii, merged_dirs, merged_surf).pipes
            if merged_segment is None:
                refined.extend(segments[k] for k in merged_indices)
            else:
                refined.append(merged_segment)
        used.update(merged_indices)
    return refined

def filter_segments(segments, min_length=0.01, min_radius=0.001, max_radius=2.0,
                    min_density=50, min_aspect_ratio=0.5):
    filtered = []
    raw_radius=[]
    refined_radius=[]
    for i,seg in enumerate(segments):
        length = np.linalg.norm(seg.centerline_end - seg.centerline_start)
        radius = seg.radius
        volume = np.pi * (radius ** 2) * max(length, 1e-6)
        density = len(seg.raw_points) / volume if volume > 0 else 0
        aspect_ratio = length / (2 * radius) if radius > 0 else 0

        if length < min_length:
            continue
        if not (min_radius <= radius <= max_radius):
            continue

        # Least-squares circle fitting in 2D projection for refined radius
        # project points orthogonal to centerline direction
        raw_radius.append(radius)
        d = seg.direction / (np.linalg.norm(seg.direction) + 1e-6)
        v = seg.surf - seg.centerline_start
        t = np.dot(v, d)
        proj = seg.centerline_start + np.outer(t, d)
        orth = seg.surf - proj
        norms = np.linalg.norm(orth, axis=1)
        refined_radii = np.mean(norms)
        seg.radius = refined_radii
        refined_radius.append(refined_radii)
        filtered.append(seg)
    return filtered,raw_radius,refined_radius

def flatten_segments(segments):
    centerline = []
    radii = []
    for seg in segments:
        centerline.append(seg.centerline_start)
        centerline.append(seg.centerline_end)
        radii.append(seg.radius)
        radii.append(seg.radius)
    return np.array(centerline), np.array(radii)


def visualize_segments(segments, labels=None, original_points=None, surface_points=None, save_path="segments.png"):
    from matplotlib import cm
    fig = plt.figure(figsize=(20,16))
    ax = fig.add_subplot(111, projection='3d')

    colors = cm.rainbow(np.linspace(0, 1, len(segments)))
    if surface_points is not None:
        ax.scatter(surface_points[:, 0], surface_points[:, 1], surface_points[:, 2],
                   s=0.1, alpha=0.1, color=[0.2, 0.2, 0.2], label=f"Cluster(surface)")
    if original_points is not None and labels is not None:
        unique_labels = np.unique(labels)
        cmap = plt.colormaps['rainbow'].resampled(len(unique_labels))

        for idx, label in enumerate(unique_labels):
            if label == -1:
            mask = labels == label
            cluster_points = original_points[mask]
            color = cmap(idx)
            ax.scatter(cluster_points[:, 0], cluster_points[:, 1], cluster_points[:, 2],
                       s=0.05, alpha=0.5, color=color, label=f"Cluster {label} (centerline)")
            # id
            mid = np.mean(cluster_points, axis=0)
            ax.text(mid[0], mid[1], mid[2], str(label),
                    color='black',  # 选择与背景对比度高的颜色
                    fontsize=6, ha='center', va='center')

    for i, seg in enumerate(segments):
        color = colors[i]
        # draw centerline
        ax.plot([seg.centerline_start[0], seg.centerline_end[0]],
                [seg.centerline_start[1], seg.centerline_end[1]],
                [seg.centerline_start[2], seg.centerline_end[2]],
                color=color, linewidth=0.5)

        # draw radius line at midpoint orthogonal to direction
        mid = (seg.centerline_start + seg.centerline_end) / 2
        # id
        ax.text(mid[0], mid[1], mid[2], str(i), color='black',
                fontsize=2, ha='center', va='center',
                bbox=dict(facecolor='white', alpha=0.4, edgecolor='none', pad=0.3))
        d = seg.direction / (np.linalg.norm(seg.direction) + 1e-6)
        if np.allclose(d, [0, 0, 1]):
            ortho = np.array([1, 0, 0])
        else:
            ortho = np.cross(d, [0, 0, 1])
            ortho /= np.linalg.norm(ortho)
        r_start = mid - seg.radius * ortho
        r_end = mid + seg.radius * ortho
        ax.plot([r_start[0], r_end[0]], [r_start[1], r_end[1]], [r_start[2], r_end[2]],
                color=color, linewidth=0.3, alpha=0.8)
    # 获取所有数据的整体范围,设置坐标轴范围
    all_points = np.concatenate([seg.centerline_start.reshape(1, 3) for seg in segments] +
                                [seg.centerline_end.reshape(1, 3) for seg in segments])
    if original_points is not None:
        all_points = np.vstack([all_points, original_points])
    min_val = np.min(all_points, axis=0)
    max_val = np.max(all_points, axis=0)
    max_range = max(max_val - min_val)  # 取最大跨度

    # 设置各轴范围（中心对齐）
    mid = (min_val + max_val) * 0.5
    ax.set_xlim(mid[0] - max_range / 2, mid[0] + max_range / 2)
    ax.set_ylim(mid[1] - max_range / 2, mid[1] + max_range / 2)
    ax.set_zlim(mid[2] - max_range / 2, mid[2] + max_range / 2)

    ax.set_title("Fitted Segments with Centerlines and Points")
    plt.tight_layout()
    plt.savefig(save_path, dpi=300)
    print(f"[Saved] {save_path}")


def evaluate_radius_estimation(raw_radius, new_radius, threshold_ratio=0.2):
    raw_radius = np.asarray(raw_radius)
    new_radius = np.asarray(new_radius)
    raw_radius[raw_radius==0] = 1e-6
    new_radius[new_radius==0] = 1e-6

    assert len(raw_radius) == len(new_radius), "Inputs must have the same length!"

    abs_errors = np.abs(new_radius - raw_radius)/raw_radius
    mean_error = np.mean(abs_errors)

    correct = np.sum(abs_errors < threshold_ratio)
    accuracy = (correct / len(raw_radius)) * 100  # 百分比

    return mean_error, accuracy

def main(input_txt):
    if '.npy' in input_txt:
        centerline_points, pipe_radii, surface_points, pipe_dirs = load_np_data(input_txt)
    if '.txt' in input_txt:
        centerline_points, pipe_radii, surface_points, pipe_dirs,offset = load_txt_data(input_txt)
    if '.pts' in input_txt:
        centerline_points, pipe_radii, surface_points, pipe_dirs = load_pts_data(input_txt)
    labels = region_growing_with_direction(centerline_points, pipe_dirs)
    segments = extract_segments(centerline_points, pipe_radii, pipe_dirs, labels)
    visualize_segments(segments, labels, centerline_points, surface_points=surface_points, save_path="step1_segmented_centerline.png")
    visualize_segments(segments,  save_path="step2_segments_ransac.png")
    segments = refine_centerline_segments_with_direction(segments)
    segments = filter_segments(segments)
    visualize_segments(segments, None, centerline_points,  save_path="step3_segments_refined.png")
    centerline, radii = flatten_segments(segments)
    print("[Done] Final centerline segments:", len(centerline) // 2)


if __name__ == "__main__":
    main("block_0_11P_0425.pts")
