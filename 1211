import numpy as np

def _normalize(v, eps=1e-8):
    v = np.asarray(v, dtype=float)
    n = np.linalg.norm(v)
    if n < eps:
        raise ValueError("Zero-length vector cannot be normalized.")
    return v / n

def gap_points_for_single_broken_cylinder(cyn1, cyn2, pc, margin=0.0):
    pc = np.asarray(pc, dtype=float)

    # 1. 把输入拆出来
    s1 = np.asarray(cyn1["start"], dtype=float)
    e1 = np.asarray(cyn1["end"], dtype=float)
    s2 = np.asarray(cyn2["start"], dtype=float)
    e2 = np.asarray(cyn2["end"], dtype=float)

    r1 = float(cyn1["radius"])
    r2 = float(cyn2["radius"])
    r_max = max(r1, r2)

    # 2. 用第一段柱体定义轴向
    axis_vec = e1 - s1
    u = _normalize(axis_vec)  # 单位向量，表示柱子的方向

    origin = s1  # 作为投影参考点

    # 3. 计算两段柱子的轴向范围
    def proj(p):
        # 点 p 在轴向上的标量坐标：t = dot(p - origin, u)
        return np.dot(p - origin, u)

    s1_t = proj(s1)
    e1_t = proj(e1)
    s2_t = proj(s2)
    e2_t = proj(e2)

    seg1_min = min(s1_t, e1_t)
    seg1_max = max(s1_t, e1_t)
    seg2_min = min(s2_t, e2_t)
    seg2_max = max(s2_t, e2_t)

    # 4. 找到“中间断掉的那一段”的轴向区间 [gap_min, gap_max]
    if seg1_max < seg2_min:
        gap_min = seg1_max
        gap_max = seg2_min
    elif seg2_max < seg1_min:
        gap_min = seg2_max
        gap_max = seg1_min
    else:
        # 两段有重叠或者紧挨着，没有明显“空隙”
        return np.zeros((0,), dtype=int)

    if gap_max <= gap_min:
        return np.zeros((0,), dtype=int)

    # 5. 对全部点做判断
    vec = pc - origin          # (N, 3)
    t = vec @ u                # (N,)

    axis_comp = np.outer(t, u) # (N,3)
    radial_vec = vec - axis_comp
    radial_dist = np.linalg.norm(radial_vec, axis=1)

    mask = (
        (t >= gap_min) & (t <= gap_max) &
        (radial_dist <= r_max + margin)
    )

    idx = np.nonzero(mask)[0]
    return idx


# ===================== 测试代码 =====================

def build_test_data():
    """
    构造一根沿 z 轴的柱子，被掰成两段：
    第一段: z ∈ [0, 4]
    第二段: z ∈ [6, 10]
    中间空隙: z ∈ (4, 6)
    半径 = 1.0
    再造一些点云，包含：
      - 空隙区域内的点（应该被选出来）
      - 其他噪声点（不该被选出来）
    """
    # 定义两段柱体
    cyn1 = {
        "start": (0.0, 0.0, 0.0),
        "end":   (0.0, 0.0, 4.0),
        "radius": 1.0
    }
    cyn2 = {
        "start": (0.0, 0.0, 6.0),
        "end":   (0.0, 0.0, 10.0),
        "radius": 1.0
    }

    # 造一些“空隙中的点”：z 在 (4, 6) 范围，x,y 在圆内
    n_gap = 200
    z_gap = np.random.uniform(4.1, 5.9, size=n_gap)
    theta = np.random.uniform(0, 2*np.pi, size=n_gap)
    r = np.random.uniform(0, 1.0, size=n_gap)  # 半径以内

    x_gap = r * np.cos(theta)
    y_gap = r * np.sin(theta)
    gap_points = np.stack([x_gap, y_gap, z_gap], axis=1)

    # 再加一些背景噪声点
    n_noise = 800
    # 随便在一个盒子里 [-3,3]x[-3,3]x[-1,11]
    noise_points = np.random.uniform(
        low=[-3, -3, -1],
        high=[3, 3, 11],
        size=(n_noise, 3)
    )

    # 合并
    pc = np.concatenate([gap_points, noise_points], axis=0)
    return cyn1, cyn2, pc, n_gap


if __name__ == "__main__":
    np.random.seed(0)

    cyn1, cyn2, pc, n_gap_true = build_test_data()

    # 调用你的函数
    idx = gap_points_for_single_broken_cylinder(cyn1, cyn2, pc, margin=0.05)

    print("总点数:", pc.shape[0])
    print("理论上空隙里造了点数:", n_gap_true)
    print("函数找到的空隙点数:", len(idx))

    # 看看这些点的 z 范围 & 距离轴线的大致情况
    gap_pc = pc[idx]
    z_min = gap_pc[:, 2].min() if len(gap_pc) > 0 else None
    z_max = gap_pc[:, 2].max() if len(gap_pc) > 0 else None
    radial = np.linalg.norm(gap_pc[:, :2], axis=1) if len(gap_pc) > 0 else None

    print("选中点的 z 范围:", z_min, " ~ ", z_max)
    if radial is not None:
        print("选中点的径向距离: min =", radial.min(), ", max =", radial.max())
